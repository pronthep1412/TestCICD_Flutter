# android/fastlane/Fastfile - Flutter Android version management
default_platform(:android)

platform :android do
  
  before_all do
    ensure_bundle_exec
    auto_update_version if ENV['GITHUB_RUN_NUMBER']
  end

  # ‚ú® Fixed: Auto version management with proper Flutter version handling
  private_lane :auto_update_version do
    begin
      # ‡∏î‡∏∂‡∏á version ‡∏à‡∏≤‡∏Å pubspec.yaml
      pubspec_path = File.expand_path('../../pubspec.yaml')
      if File.exist?(pubspec_path)
        pubspec_content = File.read(pubspec_path)
        version_line = pubspec_content.match(/^version:\s*(.+)$/)
        if version_line
          version_string = version_line[1].strip
          # Split version and build number (format: 1.2.3+123)
          if version_string.include?('+')
            version_parts = version_string.split('+')
            new_version = version_parts[0]
            build_number = version_parts[1].to_i
          else
            new_version = version_string
            build_number = 1
          end
        else
          UI.error("Version not found in pubspec.yaml, using default")
          new_version = "1.0.0"
          build_number = 1
        end
      else
        UI.error("pubspec.yaml not found, using default version")
        new_version = "1.0.0"
        build_number = 1
      end
      
      # ‡∏™‡∏£‡πâ‡∏≤‡∏á unique versionCode ‡∏à‡∏≤‡∏Å GitHub environment
      run_number = ENV['GITHUB_RUN_NUMBER'] ? ENV['GITHUB_RUN_NUMBER'].to_i : 1
      branch = ENV['GITHUB_REF_NAME'] || 'develop'
      
      # Base number ‡∏ï‡∏≤‡∏° branch ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á version conflict
      base = case branch
             when 'master' then 2000000    # Production: 2M+
             when 'preprod' then 1500000   # PreProd: 1.5M+
             else 1000000                  # Develop: 1M+
             end
      
      version_code = base + run_number
      
      # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Android version ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Flutter command
      sh("cd .. && flutter build appbundle --build-name=#{new_version} --build-number=#{version_code} --release --no-tree-shake-icons") do |status|
        if status.success?
          UI.success("‚úÖ Flutter build completed with version update")
        else
          UI.error("‚ùå Flutter build failed, falling back to gradle version update")
          
          # Fallback: ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÉ‡∏ô build.gradle ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ sed command
          gradle_file = "../app/build.gradle"
          sh("sed -i 's/versionName \".*\"/versionName \"#{new_version}\"/' #{gradle_file}")
          sh("sed -i 's/versionCode [0-9]*/versionCode #{version_code}/' #{gradle_file}")
        end
      end
      
      UI.success("‚úÖ Auto updated Flutter Android version:")
      UI.success("   versionName: #{new_version}")
      UI.success("   versionCode: #{version_code}")
      UI.success("   branch: #{branch}")
      
    rescue => e
      UI.error("‚ùå Failed to auto update version: #{e.message}")
      UI.error("Continuing with existing version...")
    end
  end

  # ‚ú® Alternative: Manual version management
  lane :set_version do |options|
    version_name = options[:version_name] || prompt(text: "Enter version name (e.g., 1.2.3):")
    version_code = options[:version_code] || prompt(text: "Enter version code (e.g., 1000123):").to_i
    
    # Update pubspec.yaml first
    pubspec_path = "../pubspec.yaml"
    pubspec_content = File.read(pubspec_path)
    updated_content = pubspec_content.gsub(/^version:\s*.*$/, "version: #{version_name}+#{version_code}")
    File.write(pubspec_path, updated_content)
    
    # Then build with Flutter
    sh("cd .. && flutter build appbundle --build-name=#{version_name} --build-number=#{version_code} --release")
    
    UI.success("‚úÖ Manually set Flutter Android version:")
    UI.success("   versionName: #{version_name}")
    UI.success("   versionCode: #{version_code}")
  end

  # ‚ú® Enhanced: Bump version using Flutter conventions
  lane :bump_version do |options|
    type = options[:type] || "patch"  # patch, minor, major
    
    pubspec_path = "../pubspec.yaml"
    pubspec_content = File.read(pubspec_path)
    
    # Extract current version
    version_line = pubspec_content.match(/^version:\s*(.+)$/)
    if version_line
      version_string = version_line[1].strip
      if version_string.include?('+')
        version_parts = version_string.split('+')
        current_version = version_parts[0]
        current_build = version_parts[1].to_i
      else
        current_version = version_string
        current_build = 1
      end
    else
      current_version = "1.0.0"
      current_build = 1
    end
    
    # Parse semantic version
    version_parts = current_version.split('.').map(&:to_i)
    
    case type
    when "major"
      version_parts[0] += 1
      version_parts[1] = 0
      version_parts[2] = 0
    when "minor"
      version_parts[1] += 1
      version_parts[2] = 0
    when "patch"
      version_parts[2] += 1
    end
    
    new_version = version_parts.join('.')
    new_build = current_build + 1
    
    # Update pubspec.yaml
    updated_content = pubspec_content.gsub(/^version:\s*.*$/, "version: #{new_version}+#{new_build}")
    File.write(pubspec_path, updated_content)
    
    # Build with Flutter
    sh("cd .. && flutter build appbundle --build-name=#{new_version} --build-number=#{new_build} --release")
    
    UI.success("‚úÖ Bumped #{type} version:")
    UI.success("   #{current_version} -> #{new_version}")
    UI.success("   build: #{current_build} -> #{new_build}")
  end

  # üöÄ Deployment lanes (updated for Flutter)
  lane :deploy_develop do
    UI.message("üöÄ Deploying Flutter Android to Internal Testing...")
    build_and_deploy(
      track: 'internal',
      release_status: 'draft'
    )
    # notify_slack("üöÄ Flutter Android Development build deployed to Internal Testing!")
  end

  lane :deploy_preprod do
    UI.message("üöÄ Deploying Flutter Android to Alpha Testing...")
    build_and_deploy(
      track: 'alpha',
      release_status: 'draft'
    )
    # notify_slack("üöÄ Flutter Android Pre-production build deployed to Alpha!")
  end

  lane :deploy_master do
    UI.message("üéâ Deploying Flutter Android to Production...")
    build_and_deploy(
      track: 'production',
      release_status: 'draft',
      rollout: '0.1'  # 10% rollout for safety
    )
    # notify_slack("üéâ Flutter Android Production build deployed with 10% rollout!")
  end

  lane :build_only do
    UI.message("üî® Building Flutter release AAB...")
    
    # Check if we already have a built AAB from the main workflow
    aab_path = "build/app/outputs/bundle/release/app-release.aab"
    if File.exist?(aab_path)
      UI.success("‚úÖ Found existing Flutter AAB, skipping build step")
    else
      UI.message("üîÑ Building fresh Flutter AAB...")
      sh("cd .. && flutter build appbundle --release")
    end
    
    if File.exist?(aab_path)
      file_size = (File.size(aab_path) / 1024.0 / 1024.0).round(2)
      UI.success("‚úÖ Flutter build completed successfully! AAB size: #{file_size} MB")
    else
      UI.error("‚ùå Flutter AAB not found after build!")
    end
  end

  # üîß Private lanes
  private_lane :build_and_deploy do |options|
    # Ensure we have a built AAB
    aab_path = "build/app/outputs/bundle/release/app-release.aab"
    
    if !File.exist?(aab_path)
      UI.message("üîÑ Building Flutter AAB...")
      sh("cd .. && flutter build appbundle --release")
    end
    
    if !File.exist?(aab_path)
      UI.error("‚ùå Flutter AAB not found! Cannot proceed with deployment.")
      raise "AAB file not found"
    end
    
    # Upload to Play Store
    upload_to_play_store(
      track: options[:track],
      json_key: "google-play-key.json",
      aab: aab_path,
      release_status: options[:release_status],
      rollout: options[:rollout],
      package_name: "test.cicd.appibc",  # Update this to your Flutter app's package name
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      timeout: 300
    )
    
    UI.success("‚úÖ Successfully uploaded Flutter AAB to #{options[:track]} track!")
  end

  # üÜï Flutter specific lanes
  lane :flutter_clean do
    UI.message("üßπ Cleaning Flutter project...")
    sh("cd .. && flutter clean")
    sh("cd .. && flutter pub get")
    UI.success("‚úÖ Flutter project cleaned and dependencies restored")
  end

  lane :flutter_analyze do
    UI.message("üîç Running Flutter code analysis...")
    sh("cd .. && flutter analyze")
    UI.success("‚úÖ Flutter code analysis completed")
  end

  lane :flutter_test do
    UI.message("üß™ Running Flutter tests...")
    sh("cd .. && flutter test")
    UI.success("‚úÖ Flutter tests completed")
  end

  lane :flutter_build_debug do
    UI.message("üî® Building Flutter debug APK...")
    sh("cd .. && flutter build apk --debug")
    
    apk_path = "../build/app/outputs/flutter-apk/app-debug.apk"
    if File.exist?(apk_path)
      file_size = (File.size(apk_path) / 1024.0 / 1024.0).round(2)
      UI.success("‚úÖ Flutter debug APK built successfully! Size: #{file_size} MB")
    else
      UI.error("‚ùå Flutter debug APK not found!")
    end
  end

  private_lane :notify_slack do |message|
    return unless ENV["SLACK_URL"]
    
    begin
      slack(
        message: message,
        channel: "#releases",
        webhook_url: ENV["SLACK_URL"],
        username: "Flutter Android CI/CD",
        icon_emoji: ":robot_face:"
      )
    rescue => e
      UI.error("Failed to send Slack notification: #{e.message}")
    end
  end

  # Error handling
  error do |lane, exception|
    error_message = "‚ùå Flutter Android deployment failed in lane '#{lane}': #{exception.message}"
    UI.error(error_message)
    # notify_slack(error_message) if defined?(notify_slack)
    raise exception
  end
end