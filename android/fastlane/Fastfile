# android/fastlane/Fastfile - Flutter Android version management (FIXED)
default_platform(:android)

platform :android do
  
  before_all do
    ensure_bundle_exec
    auto_update_version if ENV['GITHUB_RUN_NUMBER']
  end

  # âœ¨ FIXED: Enhanced path resolution and debugging
  private_lane :get_aab_path do
    # Get the absolute path to avoid working directory issues
    project_root = File.expand_path('../..', __dir__)
    aab_relative_path = "build/app/outputs/bundle/release/app-release.aab"
    aab_path = File.join(project_root, aab_relative_path)
    
    UI.message("ðŸ” Path Resolution Debug:")
    UI.message("   Current Dir: #{Dir.pwd}")
    UI.message("   Project Root: #{project_root}")
    UI.message("   AAB Relative: #{aab_relative_path}")
    UI.message("   AAB Absolute: #{aab_path}")
    
    return aab_path
  end

  # âœ¨ FIXED: Better file verification with detailed logging
  private_lane :verify_aab_exists do
    aab_path = get_aab_path
    
    UI.message("ðŸ” AAB Verification:")
    UI.message("   Checking: #{aab_path}")
    
    if File.exist?(aab_path)
      file_size = File.size(aab_path)
      file_size_mb = (file_size / 1024.0 / 1024.0).round(2)
      
      if file_size > 0
        UI.success("âœ… AAB found and valid!")
        UI.success("   Size: #{file_size_mb} MB (#{file_size} bytes)")
        UI.success("   Path: #{aab_path}")
        return true
      else
        UI.error("âŒ AAB file exists but is empty!")
        return false
      end
    else
      UI.error("âŒ AAB file not found!")
      
      # Enhanced debugging - search for AAB files
      UI.message("ðŸ” Searching for AAB files in project:")
      project_root = File.expand_path('../..', __dir__)
      
      Find.find(project_root) do |path|
        if path =~ /\.aab$/
          UI.message("   Found AAB: #{path}")
          if File.exist?(path)
            size_mb = (File.size(path) / 1024.0 / 1024.0).round(2)
            UI.message("   Size: #{size_mb} MB")
          end
        end
      rescue => e
        # Skip permission denied errors
      end
      
      return false
    end
  end

  # âœ¨ FIXED: Auto version management with proper Flutter version handling
  private_lane :auto_update_version do
    begin
      # à¸”à¸¶à¸‡ version à¸ˆà¸²à¸ pubspec.yaml
      pubspec_path = File.expand_path('../../pubspec.yaml')
      if File.exist?(pubspec_path)
        pubspec_content = File.read(pubspec_path)
        version_line = pubspec_content.match(/^version:\s*(.+)$/)
        if version_line
          version_string = version_line[1].strip
          # Split version and build number (format: 1.2.3+123)
          if version_string.include?('+')
            version_parts = version_string.split('+')
            new_version = version_parts[0]
            build_number = version_parts[1].to_i
          else
            new_version = version_string
            build_number = 1
          end
        else
          UI.error("Version not found in pubspec.yaml, using default")
          new_version = "1.0.0"
          build_number = 1
        end
      else
        UI.error("pubspec.yaml not found, using default version")
        new_version = "1.0.0"
        build_number = 1
      end
      
      # à¸ªà¸£à¹‰à¸²à¸‡ unique versionCode à¸ˆà¸²à¸ GitHub environment
      run_number = ENV['GITHUB_RUN_NUMBER'] ? ENV['GITHUB_RUN_NUMBER'].to_i : 1
      branch = ENV['GITHUB_REF_NAME'] || 'develop'
      
      # Base number à¸•à¸²à¸¡ branch à¹€à¸žà¸·à¹ˆà¸­à¸«à¸¥à¸µà¸à¹€à¸¥à¸µà¹ˆà¸¢à¸‡ version conflict
      base = case branch
             when 'master' then 2000000    # Production: 2M+
             when 'preprod' then 1500000   # PreProd: 1.5M+
             else 1000000                  # Develop: 1M+
             end
      
      version_code = base + run_number
      
      UI.success("âœ… Version Information:")
      UI.success("   Version Name: #{new_version}")
      UI.success("   Version Code: #{version_code}")
      UI.success("   Branch: #{branch}")
      UI.success("   Run Number: #{run_number}")
      
      # âœ¨ FIXED: Check if AAB already exists before building
      if verify_aab_exists
        UI.success("âœ… AAB already exists, skipping build in auto_update_version")
        return
      end
      
      # Only build if AAB doesn't exist
      UI.message("ðŸ”„ Building Flutter AAB with version update...")
      
      sh("cd .. && flutter build appbundle --build-name=#{new_version} --build-number=#{version_code} --release --no-tree-shake-icons") do |status|
        if status.success?
          UI.success("âœ… Flutter build completed with version update")
          
          # Verify the build was successful
          if verify_aab_exists
            UI.success("âœ… AAB verified after build")
          else
            UI.error("âŒ AAB not found after successful build - this is unexpected!")
          end
        else
          UI.error("âŒ Flutter build failed, falling back to gradle version update")
          
          # Fallback: à¸­à¸±à¸žà¹€à¸”à¸—à¹ƒà¸™ build.gradle à¹‚à¸”à¸¢à¹ƒà¸Šà¹‰ sed command
          gradle_file = "../app/build.gradle"
          sh("sed -i 's/versionName \".*\"/versionName \"#{new_version}\"/' #{gradle_file}")
          sh("sed -i 's/versionCode [0-9]*/versionCode #{version_code}/' #{gradle_file}")
        end
      end
      
    rescue => e
      UI.error("âŒ Failed to auto update version: #{e.message}")
      UI.error("Continuing with existing version...")
    end
  end

  # âœ¨ Alternative: Manual version management
  lane :set_version do |options|
    version_name = options[:version_name] || prompt(text: "Enter version name (e.g., 1.2.3):")
    version_code = options[:version_code] || prompt(text: "Enter version code (e.g., 1000123):").to_i
    
    # Update pubspec.yaml first
    pubspec_path = "../pubspec.yaml"
    pubspec_content = File.read(pubspec_path)
    updated_content = pubspec_content.gsub(/^version:\s*.*$/, "version: #{version_name}+#{version_code}")
    File.write(pubspec_path, updated_content)
    
    # Then build with Flutter
    sh("cd .. && flutter build appbundle --build-name=#{version_name} --build-number=#{version_code} --release")
    
    UI.success("âœ… Manually set Flutter Android version:")
    UI.success("   versionName: #{version_name}")
    UI.success("   versionCode: #{version_code}")
  end

  # âœ¨ Enhanced: Bump version using Flutter conventions
  lane :bump_version do |options|
    type = options[:type] || "patch"  # patch, minor, major
    
    pubspec_path = "../pubspec.yaml"
    pubspec_content = File.read(pubspec_path)
    
    # Extract current version
    version_line = pubspec_content.match(/^version:\s*(.+)$/)
    if version_line
      version_string = version_line[1].strip
      if version_string.include?('+')
        version_parts = version_string.split('+')
        current_version = version_parts[0]
        current_build = version_parts[1].to_i
      else
        current_version = version_string
        current_build = 1
      end
    else
      current_version = "1.0.0"
      current_build = 1
    end
    
    # Parse semantic version
    version_parts = current_version.split('.').map(&:to_i)
    
    case type
    when "major"
      version_parts[0] += 1
      version_parts[1] = 0
      version_parts[2] = 0
    when "minor"
      version_parts[1] += 1
      version_parts[2] = 0
    when "patch"
      version_parts[2] += 1
    end
    
    new_version = version_parts.join('.')
    new_build = current_build + 1
    
    # Update pubspec.yaml
    updated_content = pubspec_content.gsub(/^version:\s*.*$/, "version: #{new_version}+#{new_build}")
    File.write(pubspec_path, updated_content)
    
    # Build with Flutter
    sh("cd .. && flutter build appbundle --build-name=#{new_version} --build-number=#{new_build} --release")
    
    UI.success("âœ… Bumped #{type} version:")
    UI.success("   #{current_version} -> #{new_version}")
    UI.success("   build: #{current_build} -> #{new_build}")
  end

  # ðŸš€ Deployment lanes (updated for Flutter)
  lane :deploy_develop do
    UI.message("ðŸš€ Deploying Flutter Android to Internal Testing...")
    build_and_deploy(
      track: 'internal',
      release_status: 'draft'
    )
    # notify_slack("ðŸš€ Flutter Android Development build deployed to Internal Testing!")
  end

  lane :deploy_preprod do
    UI.message("ðŸš€ Deploying Flutter Android to Alpha Testing...")
    build_and_deploy(
      track: 'alpha',
      release_status: 'draft'
    )
    # notify_slack("ðŸš€ Flutter Android Pre-production build deployed to Alpha!")
  end

  lane :deploy_master do
    UI.message("ðŸŽ‰ Deploying Flutter Android to Production...")
    build_and_deploy(
      track: 'production',
      release_status: 'draft',
      rollout: '0.1'  # 10% rollout for safety
    )
    # notify_slack("ðŸŽ‰ Flutter Android Production build deployed with 10% rollout!")
  end

  # âœ¨ FIXED: Enhanced build_only lane with better verification
  lane :build_only do
    UI.message("ðŸ”¨ Building Flutter release AAB...")
    
    # Check if we already have a built AAB
    if verify_aab_exists
      UI.success("âœ… Found existing Flutter AAB, skipping build step")
      return
    end
    
    UI.message("ðŸ”„ Building fresh Flutter AAB...")
    sh("cd .. && flutter build appbundle --release")
    
    # Verify the build
    if verify_aab_exists
      UI.success("âœ… Flutter build completed successfully!")
    else
      UI.error("âŒ Flutter AAB not found after build!")
      raise "AAB build verification failed"
    end
  end

  # ðŸ”§ FIXED: Enhanced private lane with better error handling
  private_lane :build_and_deploy do |options|
    UI.message("ðŸš€ Starting build and deploy process...")
    UI.message("   Track: #{options[:track]}")
    UI.message("   Release Status: #{options[:release_status]}")
    UI.message("   Rollout: #{options[:rollout] || 'N/A'}")
    
    # âœ¨ FIXED: Smart AAB handling - don't build if it already exists
    if verify_aab_exists
      UI.success("âœ… Using existing AAB file")
    else
      UI.message("ðŸ”„ AAB not found, building Flutter AAB...")
      
      begin
        sh("cd .. && flutter build appbundle --release")
        
        # Verify the build was successful
        if verify_aab_exists
          UI.success("âœ… Flutter AAB built successfully")
        else
          UI.error("âŒ AAB build failed - file not found after build")
          raise "AAB build verification failed"
        end
      rescue => e
        UI.error("âŒ Flutter build failed: #{e.message}")
        raise "Flutter build failed: #{e.message}"
      end
    end
    
    # âœ¨ FIXED: Use the path helper for consistent path resolution
    aab_path = get_aab_path
    
    # Final verification before upload
    unless File.exist?(aab_path)
      UI.error("âŒ AAB file not found at final check: #{aab_path}")
      UI.error("This should not happen - please check the build process")
      raise "AAB file not found before upload"
    end
    
    # Get file info for logging
    file_size = File.size(aab_path)
    file_size_mb = (file_size / 1024.0 / 1024.0).round(2)
    
    UI.success("âœ… AAB ready for upload:")
    UI.success("   Path: #{aab_path}")
    UI.success("   Size: #{file_size_mb} MB")
    
    # Upload to Play Store
    begin
      upload_to_play_store(
        track: options[:track],
        json_key: "google-play-key.json",
        aab: aab_path,
        release_status: options[:release_status],
        rollout: options[:rollout],
        package_name: "test.cicd.appibc",  # Update this to your Flutter app's package name
        skip_upload_metadata: true,
        skip_upload_images: true,
        skip_upload_screenshots: true,
        timeout: 300
      )
      
      UI.success("âœ… Successfully uploaded Flutter AAB to #{options[:track]} track!")
      
    rescue => e
      UI.error("âŒ Upload to Play Store failed: #{e.message}")
      raise "Play Store upload failed: #{e.message}"
    end
  end

  # ðŸ†• Flutter specific lanes
  lane :flutter_clean do
    UI.message("ðŸ§¹ Cleaning Flutter project...")
    sh("cd .. && flutter clean")
    sh("cd .. && flutter pub get")
    UI.success("âœ… Flutter project cleaned and dependencies restored")
  end

  lane :flutter_analyze do
    UI.message("ðŸ” Running Flutter code analysis...")
    sh("cd .. && flutter analyze")
    UI.success("âœ… Flutter code analysis completed")
  end

  lane :flutter_test do
    UI.message("ðŸ§ª Running Flutter tests...")
    sh("cd .. && flutter test")
    UI.success("âœ… Flutter tests completed")
  end

  lane :flutter_build_debug do
    UI.message("ðŸ”¨ Building Flutter debug APK...")
    sh("cd .. && flutter build apk --debug")
    
    apk_path = "../build/app/outputs/flutter-apk/app-debug.apk"
    if File.exist?(apk_path)
      file_size = (File.size(apk_path) / 1024.0 / 1024.0).round(2)
      UI.success("âœ… Flutter debug APK built successfully! Size: #{file_size} MB")
    else
      UI.error("âŒ Flutter debug APK not found!")
    end
  end

  # âœ¨ FIXED: Enhanced debugging lane
  lane :debug_paths do
    UI.message("ðŸ” Path Debugging Information:")
    UI.message("   Current Directory: #{Dir.pwd}")
    UI.message("   Fastfile Directory: #{__dir__}")
    
    project_root = File.expand_path('../..', __dir__)
    UI.message("   Project Root: #{project_root}")
    
    aab_path = get_aab_path
    UI.message("   Expected AAB Path: #{aab_path}")
    UI.message("   AAB Exists: #{File.exist?(aab_path)}")
    
    if File.exist?(aab_path)
      file_size = (File.size(aab_path) / 1024.0 / 1024.0).round(2)
      UI.message("   AAB Size: #{file_size} MB")
    end
    
    # List build directory contents
    build_dir = File.join(project_root, "build")
    if Dir.exist?(build_dir)
      UI.message("   Build Directory Contents:")
      Dir.glob(File.join(build_dir, "**", "*")).each do |item|
        if File.file?(item)
          UI.message("     #{item}")
        end
      end
    else
      UI.message("   Build Directory: Not found")
    end
  end

  private_lane :notify_slack do |message|
    return unless ENV["SLACK_URL"]
    
    begin
      slack(
        message: message,
        channel: "#releases",
        webhook_url: ENV["SLACK_URL"],
        username: "Flutter Android CI/CD",
        icon_emoji: ":robot_face:"
      )
    rescue => e
      UI.error("Failed to send Slack notification: #{e.message}")
    end
  end

  # âœ¨ Enhanced error handling
  error do |lane, exception|
    error_message = "âŒ Flutter Android deployment failed in lane '#{lane}': #{exception.message}"
    UI.error(error_message)
    
    # Enhanced debugging on error
    UI.error("ðŸ” Error Debug Information:")
    UI.error("   Current Directory: #{Dir.pwd}")
    UI.error("   Exception Class: #{exception.class}")
    UI.error("   Stack Trace: #{exception.backtrace.first(5).join('\n   ')}")
    
    # Try to provide helpful information
    begin
      aab_path = get_aab_path
      UI.error("   Expected AAB Path: #{aab_path}")
      UI.error("   AAB Exists: #{File.exist?(aab_path)}")
    rescue => debug_error
      UI.error("   Could not get AAB debug info: #{debug_error.message}")
    end
    
    # notify_slack(error_message) if defined?(notify_slack)
    raise exception
  end
end