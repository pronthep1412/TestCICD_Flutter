# .github/workflows/ios-reusable.yml - Complete Enhanced with comprehensive debugging
name: iOS Build & Deploy

on:
  workflow_call:
    inputs:
      version:
        required: true
        type: string
      version_code:
        required: true
        type: string
      branch:
        required: true
        type: string
      environment:
        required: false
        type: string
        default: 'development'
    secrets:
      APP_STORE_CONNECT_API_KEY_ID:
        required: true
      APP_STORE_CONNECT_API_ISSUER_ID:
        required: true
      APP_STORE_CONNECT_API_KEY:
        required: true
      MATCH_PASSWORD:
        required: true
      MATCH_GIT_URL:
        required: true
      MATCH_PRIVATE_KEY:
        required: true
  
  workflow_dispatch:
    inputs:
      version:
        description: 'Version (e.g., 1.2.3)'
        required: true
        default: '1.0.0'
      version_code:
        description: 'Version code (e.g., 123)'
        required: true
        default: '1'
      branch:
        description: 'Branch name'
        required: true
        default: 'develop'
      environment:
        description: 'Environment'
        required: false
        default: 'development'

env:
  FLUTTER_VERSION: '3.32.2'

jobs:
  build-and-deploy-ios:
    runs-on: macos-latest
    timeout-minutes: 35
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: System Information
        run: |
          echo "üñ•Ô∏è System Information:"
          echo "- macOS: $(sw_vers -productVersion)"
          echo "- Xcode: $(xcodebuild -version | head -1)"
          echo "- Available space: $(df -h . | tail -1 | awk '{print $4}')"
          echo "- Ruby version: $(ruby --version)"
          echo "- Bundler version: $(bundle --version 2>/dev/null || echo 'Not installed')"

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: 'stable'
          cache: true

      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.PUB_CACHE }}
            ~/.gradle/wrapper
            ~/.gradle/caches
            ~/Library/Caches/CocoaPods
            ~/Library/Developer/Xcode/DerivedData
          key: ${{ runner.os }}-flutter-ios-${{ hashFiles('pubspec.lock', 'ios/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-flutter-ios-

      - name: Get Dependencies
        run: |
          echo "üì¶ Installing Flutter dependencies..."
          flutter pub get
          echo "‚úÖ Flutter dependencies installed"

      - name: Update Version
        run: |
          echo "üìù Updating version to: ${{ inputs.version }}+${{ inputs.version_code }}"
          sed -i '' "s/^version: .*/version: ${{ inputs.version }}+${{ inputs.version_code }}/" pubspec.yaml
          grep "^version:" pubspec.yaml
          echo "‚úÖ Version updated in pubspec.yaml"

      # üîë SETUP SSH FOR FASTLANE MATCH
      - name: Setup SSH for Match
        uses: webfactory/ssh-agent@v0.9.1
        with:
          ssh-private-key: ${{ secrets.MATCH_PRIVATE_KEY }}

      # üîç ENHANCED API KEY VALIDATION
      - name: Comprehensive API Key Validation
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_API_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
        run: |
          echo "üîç Comprehensive API Key validation..."
          
          # Check basic availability
          echo "üìã Basic checks:"
          if [ -n "$APP_STORE_CONNECT_API_KEY_ID" ]; then
            echo "‚úÖ API Key ID: ${APP_STORE_CONNECT_API_KEY_ID:0:8}..."
            
            # Validate format (should be 10 chars, alphanumeric)
            if [[ "$APP_STORE_CONNECT_API_KEY_ID" =~ ^[A-Z0-9]{10}$ ]]; then
              echo "‚úÖ API Key ID format: Valid"
            else
              echo "‚ùå API Key ID format: Invalid (should be 10 alphanumeric chars)"
            fi
          else
            echo "‚ùå API Key ID: Missing"
          fi
          
          if [ -n "$APP_STORE_CONNECT_API_ISSUER_ID" ]; then
            echo "‚úÖ Issuer ID: ${APP_STORE_CONNECT_API_ISSUER_ID:0:8}..."
            
            # Validate format (should be UUID format)
            if [[ "$APP_STORE_CONNECT_API_ISSUER_ID" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
              echo "‚úÖ Issuer ID format: Valid UUID"
            else
              echo "‚ùå Issuer ID format: Invalid (should be UUID)"
            fi
          else
            echo "‚ùå Issuer ID: Missing"
          fi
          
          if [ -n "$APP_STORE_CONNECT_API_KEY_CONTENT" ]; then
            echo "‚úÖ API Key Content: Available (${#APP_STORE_CONNECT_API_KEY_CONTENT} chars)"
            
            # Test base64 decoding
            if decoded_content=$(echo "$APP_STORE_CONNECT_API_KEY_CONTENT" | base64 -d 2>/dev/null); then
              echo "‚úÖ Base64 decoding: Success"
              decoded_length=${#decoded_content}
              echo "   Decoded length: $decoded_length characters"
              
              # Check if it looks like a P8 key
              if echo "$decoded_content" | grep -q "BEGIN PRIVATE KEY" && echo "$decoded_content" | grep -q "END PRIVATE KEY"; then
                echo "‚úÖ P8 format: Valid (contains BEGIN/END PRIVATE KEY)"
                
                # Count lines (typical P8 has ~9-10 lines)
                line_count=$(echo "$decoded_content" | wc -l | tr -d ' ')
                echo "   Line count: $line_count"
                
                if [ "$line_count" -ge 8 ] && [ "$line_count" -le 15 ]; then
                  echo "‚úÖ P8 structure: Looks valid"
                else
                  echo "‚ö†Ô∏è P8 structure: Unusual line count"
                fi
              else
                echo "‚ùå P8 format: Invalid (missing BEGIN/END PRIVATE KEY)"
                echo "   First 100 chars: ${decoded_content:0:100}"
              fi
            else
              echo "‚ùå Base64 decoding: Failed"
            fi
          else
            echo "‚ùå API Key Content: Missing"
          fi
          
          # üîç TEST API KEY WITH ALTOOL
          if [ -n "$APP_STORE_CONNECT_API_KEY_ID" ] && [ -n "$APP_STORE_CONNECT_API_ISSUER_ID" ] && [ -n "$APP_STORE_CONNECT_API_KEY_CONTENT" ]; then
            echo ""
            echo "üß™ Testing API Key with altool..."
            
            # Create temporary key file
            temp_key_file="/tmp/test_api_key.p8"
            echo "$APP_STORE_CONNECT_API_KEY_CONTENT" | base64 -d > "$temp_key_file" 2>/dev/null
            
            if [ -f "$temp_key_file" ]; then
              echo "‚úÖ Temporary key file created"
              
              # Set environment for altool
              export API_PRIVATE_KEYS_DIR="/tmp"
              
              # Test API access
              echo "   Testing App Store Connect API access..."
              
              # Try to list apps
              if altool_output=$(xcrun altool --list-apps --apiKey "$APP_STORE_CONNECT_API_KEY_ID" --apiIssuer "$APP_STORE_CONNECT_API_ISSUER_ID" -t ios 2>&1); then
                echo "‚úÖ altool API test: Success"
                
                if echo "$altool_output" | grep -q "No Applications found"; then
                  echo "‚ö†Ô∏è No applications found (API works but no apps in account)"
                else
                  echo "‚úÖ Found applications in account"
                  # Show app count (but not details for security)
                  app_count=$(echo "$altool_output" | grep -c "Bundle ID" || echo "0")
                  echo "   App count: $app_count"
                fi
              else
                echo "‚ùå altool API test: Failed"
                echo "   Error output:"
                echo "$altool_output" | head -10  # Limit error output
                
                # Analyze common error patterns
                if echo "$altool_output" | grep -qi "unauthorized"; then
                  echo "üí° Issue: API key lacks proper permissions"
                elif echo "$altool_output" | grep -qi "invalid"; then
                  echo "üí° Issue: API key format or content invalid"
                elif echo "$altool_output" | grep -qi "team"; then
                  echo "üí° Issue: Team/organization access problem"
                else
                  echo "üí° Issue: Unknown API error"
                fi
              fi
              
              # Cleanup
              rm -f "$temp_key_file"
            else
              echo "‚ùå Failed to create temporary key file"
            fi
          else
            echo "‚ö†Ô∏è Skipping altool test - missing required API key components"
          fi

      # üîç TEST SSH CONNECTION
      - name: Test SSH Connection to Match Repository
        run: |
          echo "üîç Testing SSH connection to Match repository..."
          
          # Test SSH connection to GitHub
          echo "Testing GitHub SSH connection..."
          if ssh -T git@github.com -o StrictHostKeyChecking=no 2>&1 | grep -q "successfully authenticated"; then
            echo "‚úÖ GitHub SSH: Success"
          else
            echo "‚ö†Ô∏è GitHub SSH: May have issues (but this is often normal)"
          fi
          
          # Test specific repository access
          echo "Testing access to Match repository..."
          if git ls-remote "${{ secrets.MATCH_GIT_URL }}" >/dev/null 2>&1; then
            echo "‚úÖ Match repository: Accessible"
          else
            echo "‚ùå Match repository: Not accessible"
            echo "   URL: ${{ secrets.MATCH_GIT_URL }}"
          fi
          
          # Show SSH key info
          echo "SSH key info:"
          ssh-add -l 2>/dev/null || echo "No SSH keys loaded"

      # üì± INSTALL COCOAPODS DEPENDENCIES
      - name: Install CocoaPods Dependencies
        run: |
          echo "üì± Installing CocoaPods dependencies..."
          cd ios
          
          # Show current CocoaPods version
          echo "CocoaPods version: $(pod --version)"
          
          # Check if cache hit
          if [ -d "Pods" ] && [ -f "Podfile.lock" ]; then
            echo "‚úÖ Pods cache found, verifying integrity..."
            if pod install --deployment 2>/dev/null; then
              echo "‚úÖ Cache is valid"
            else
              echo "‚ö†Ô∏è Cache invalid, reinstalling..."
              rm -rf Pods Podfile.lock
              pod install
            fi
          else
            echo "üîÑ Installing fresh Pods..."
            pod install
          fi
          
          echo "‚úÖ CocoaPods installation completed"

      # üîß Enhanced Ruby setup for Fastlane
      - name: Setup Ruby for Fastlane
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true
          working-directory: ios

      # üî® BUILD & DEPLOY WITH ENHANCED LOGGING
      - name: Build and Deploy iOS
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_API_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          FL_UPDATE_PLIST_PATH: Runner/Info.plist
          FASTLANE_VERBOSE: true
        run: |
          echo "üçé Building and deploying iOS..."
          
          # Determine deployment target based on branch
          case "${{ inputs.branch }}" in
            "main") 
              TARGET="app_store"
              echo "üè™ Target: App Store"
              ;;
            "staging") 
              TARGET="testflight_beta"
              echo "‚úàÔ∏è Target: TestFlight Beta"
              ;;
            *) 
              TARGET="testflight_internal"
              echo "üîí Target: TestFlight Internal"
              ;;
          esac
          
          # Log build start time
          BUILD_START_TIME=$(date)
          echo "‚è±Ô∏è Build started at: $BUILD_START_TIME"
          
          # Pre-build validation
          echo ""
          echo "üìã Final build configuration:"
          echo "- Target: $TARGET"
          echo "- Version: ${{ inputs.version }}"
          echo "- Build: ${{ inputs.version_code }}"
          echo "- Branch: ${{ inputs.branch }}"
          echo "- API Key ID: ${APP_STORE_CONNECT_API_KEY_ID:0:8}..."
          
          # Navigate to iOS directory
          cd ios
          
          # Show Fastlane version
          echo ""
          echo "üìã Fastlane info:"
          bundle exec fastlane --version
          
          # üöÄ START DEPLOYMENT
          echo ""
          echo "üöÄ Starting deployment..."
          echo "‚è±Ô∏è Fastlane started at: $(date)"
          
          # Run with enhanced error handling
          if bundle exec fastlane deploy \
            target:$TARGET \
            version:"${{ inputs.version }}" \
            build_number:"${{ inputs.version_code }}"; then
            
            echo ""
            echo "‚úÖ iOS deployment completed successfully!"
            echo "‚è±Ô∏è Fastlane finished at: $(date)"
            
          else
            FASTLANE_EXIT_CODE=$?
            echo ""
            echo "‚ùå Fastlane deployment failed with exit code: $FASTLANE_EXIT_CODE"
            echo "‚è±Ô∏è Fastlane failed at: $(date)"
            
            # üîç POST-FAILURE ANALYSIS
            echo ""
            echo "üîç Post-failure analysis:"
            
            # Check for common files/logs
            echo "üìã Checking for debug information..."
            
            if [ -d "fastlane/logs" ]; then
              echo "‚úÖ Fastlane logs directory found"
              ls -la fastlane/logs/
              
              # Show recent log content (last 50 lines)
              if ls fastlane/logs/*.log >/dev/null 2>&1; then
                echo ""
                echo "üìã Recent fastlane log content (last 50 lines):"
                tail -50 fastlane/logs/*.log | head -50
              fi
            else
              echo "‚ùå No fastlane logs directory found"
            fi
            
            if [ -d "build" ]; then
              echo "‚úÖ Build directory found"
              ls -la build/
            else
              echo "‚ùå No build directory found"
            fi
            
            exit $FASTLANE_EXIT_CODE
          fi

      # üîç POST-BUILD ANALYSIS
      - name: Post-Build Analysis
        if: always()
        run: |
          echo "üîç Post-build analysis..."
          
          echo "üìã Build artifacts:"
          if [ -d "ios/build" ]; then
            echo "‚úÖ Build directory exists"
            find ios/build -type f -name "*.ipa" -o -name "*.app" -o -name "*.dSYM*" | while read file; do
              size=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "unknown")
              echo "   $file ($size)"
            done
          else
            echo "‚ùå No build directory found"
          fi
          
          echo ""
          echo "üìã Fastlane logs:"
          if [ -d "ios/fastlane/logs" ]; then
            echo "‚úÖ Fastlane logs directory exists"
            ls -la ios/fastlane/logs/
          else
            echo "‚ùå No fastlane logs directory found"
          fi

      # üìä VERIFY BUILD ARTIFACTS
      - name: Verify Build Artifacts
        run: |
          echo "üîç Verifying build artifacts..."
          
          # Check for IPA file
          if find ios -name "*.ipa" -type f | head -1 | read ipa_file; then
            echo "‚úÖ IPA found: $ipa_file"
            ipa_size=$(ls -lh "$ipa_file" | awk '{print $5}')
            echo "   Size: $ipa_size"
            
            # Basic IPA validation
            if unzip -t "$ipa_file" >/dev/null 2>&1; then
              echo "‚úÖ IPA file integrity: Valid"
            else
              echo "‚ùå IPA file integrity: Corrupted"
            fi
          else
            echo "‚ö†Ô∏è No IPA file found (may be normal for direct upload)"
          fi
          
          # Check Fastlane logs
          if [ -d "ios/fastlane/logs" ]; then
            echo "üìã Fastlane logs available"
            log_count=$(ls -1 ios/fastlane/logs/ 2>/dev/null | wc -l | tr -d ' ')
            echo "   Log files: $log_count"
          fi

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ios-${{ inputs.version }}-${{ github.run_number }}
          path: |
            ios/build/
            ios/fastlane/logs/
            ios/*.ipa
          retention-days: 30

      - name: Build Summary
        if: always()
        run: |
          echo "## üçé iOS Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${{ inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Number:** ${{ inputs.version_code }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ inputs.branch }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Runner:** ${{ runner.os }} ($(sw_vers -productVersion))" >> $GITHUB_STEP_SUMMARY
          echo "- **Flutter:** ${{ env.FLUTTER_VERSION }}" >> $GITHUB_STEP_SUMMARY
          
          # Show deployment target
          case "${{ inputs.branch }}" in
            "main") echo "- **Target:** üè™ App Store" >> $GITHUB_STEP_SUMMARY ;;
            "staging") echo "- **Target:** ‚úàÔ∏è TestFlight Beta" >> $GITHUB_STEP_SUMMARY ;;
            *) echo "- **Target:** üîí TestFlight Internal" >> $GITHUB_STEP_SUMMARY ;;
          esac
          
          # Check for IPA and show size
          if find ios -name "*.ipa" -type f | head -1 | read ipa_file; then
            size=$(ls -lh "$ipa_file" | awk '{print $5}')
            echo "- **IPA Size:** $size" >> $GITHUB_STEP_SUMMARY
            echo "- **Build Status:** ‚úÖ IPA Generated" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Build Status:** ‚ö†Ô∏è No IPA found" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*Build completed on $(date)*" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up sensitive files and temporary data..."
          
          # Clean up any temporary API key files
          rm -f /tmp/test_api_key.p8 2>/dev/null || true
          rm -f /tmp/api_key.p8 2>/dev/null || true
          
          # Clean up any temporary build files
          rm -rf ios/build/temp 2>/dev/null || true
          rm -rf ios/fastlane/tmp 2>/dev/null || true
          rm -rf ios/ipa_inspection 2>/dev/null || true
          
          echo "‚úÖ Cleanup completed"