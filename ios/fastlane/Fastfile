# ios/fastlane/Fastfile - Static iOS Fastlane Configuration
default_platform(:ios)

platform :ios do
  
  before_all do
    setup_ci if ENV['CI']
    ensure_bundle_exec
  end

  desc "Deploy to TestFlight"
  lane :deploy do |options|
    UI.message("üöÄ Deploying Flutter iOS to TestFlight...")
    
    # Setup certificates
    setup_certificates
    
    # Build app
    build_flutter_app
    
    # Upload to TestFlight with API key object
    upload_to_testflight_with_api_key(
      groups: ["Internal Testers"],
      skip_waiting: true
    )
    
    UI.success("üéâ Successfully deployed to TestFlight!")
  end

  desc "Build only"
  lane :build do
    UI.message("üî® Building Flutter iOS app...")
    setup_certificates
    build_flutter_app
    UI.success("‚úÖ Flutter iOS build completed!")
  end

  # üîê Setup certificates (same as React Native style)
  private_lane :setup_certificates do
    UI.message("üîê Setting up certificates...")
    
    match(
      type: "appstore",
      readonly: false  # ‚Üê false ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á cert ‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ
    )
    
    UI.success("‚úÖ Certificates setup completed")
  end

  # üî® Build Flutter app
  private_lane :build_flutter_app do
    # Build Flutter app first
    sh("cd ../.. && flutter build ios --release --no-codesign")
    
    # Then build with Xcode
    build_app(
      scheme: "Runner",
      workspace: "Runner.xcworkspace", 
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      output_directory: "./build",
      output_name: "Runner.ipa",
      include_bitcode: false,
      export_options: {
        provisioningProfiles: {
          ENV['APP_BUNDLE_ID'] || "test.cicd.appibc" => "match AppStore #{ENV['APP_BUNDLE_ID'] || 'test.cicd.appibc'}"
        }
      }
    )
  end

  # üöÄ Upload with API Key Object (same structure as React Native)
  private_lane :upload_to_testflight_with_api_key do |options|
    upload_options = {
      skip_waiting_for_build_processing: options[:skip_waiting] || true,
      groups: options[:groups] || ["Internal Testers"],
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Automated Flutter build from #{ENV['GITHUB_REF_NAME'] || 'main'} branch"
    }
    
    # ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á API key object (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô React Native)
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_raw_content = ENV['APP_STORE_CONNECT_API_KEY']
    
    if api_key_id && api_issuer_id && api_key_raw_content
      begin
        # ‡πÉ‡∏ä‡πâ raw content ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á decode ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà base64)
        api_key_content = api_key_raw_content
        
        UI.message("‚úÖ Creating App Store Connect API configuration")
        UI.message("   Key ID: #{api_key_id}")
        UI.message("   Issuer ID: #{api_issuer_id}")
        UI.message("   Content length: #{api_key_content.length} characters")
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á API key object (structure ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô React Native)
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,  # ‚Üê ‡πÉ‡∏ä‡πâ "key" ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà "key_content"
          duration: 1200,
          in_house: false
        }
        
        upload_options[:api_key] = app_store_connect_api_key
        UI.success("‚úÖ Using App Store Connect API for TestFlight upload")
        
      rescue => e
        UI.error("‚ùå Failed to setup API key: #{e.message}")
        UI.message("‚ö†Ô∏è Falling back to traditional auth")
      end
    else
      UI.message("‚ö†Ô∏è API key not available, using traditional auth")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_raw_content
      UI.message("Missing: #{missing_items.join(', ')}")
    end
    
    upload_to_testflight(upload_options)
  end

  # Error handling
  error do |lane, exception|
    error_message = "‚ùå Flutter iOS deployment failed in lane '#{lane}': #{exception.message}"
    UI.error(error_message)
    raise exception
  end
end