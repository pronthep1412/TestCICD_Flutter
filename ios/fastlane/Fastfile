# ios/fastlane/Fastfile - Enhanced with comprehensive debugging
default_platform(:ios)

platform :ios do
  before_all do
    ENV["FASTLANE_SKIP_UPDATE_CHECK"] = "1"
    setup_ci if ENV['CI']
  end

  desc "Deploy to App Store Connect"
  lane :deploy do |options|
    target = options[:target] || "testflight_internal"
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("üçé Building and deploying iOS")
    UI.message("üéØ Target: #{target}")
    UI.message("üìã Version: #{version} (#{build_number})")
    
    # üîß Setup certificates and provisioning profiles with Match + API Key
    setup_certificates_with_api_key
    
    # Update version numbers
    increment_version_number(version_number: version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter iOS (without codesign - Fastlane will handle it)
    sh("cd .. && flutter build ios --release --no-codesign --build-name=#{version} --build-number=#{build_number}")
    
    # Build and archive with Xcode
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "build",
      output_name: "Runner.ipa",
      silent: false  # üîç ‡πÄ‡∏õ‡∏¥‡∏î verbose logging
    )
    
    # üîç POST-BUILD VALIDATION
    validate_ipa_build
    
    # Deploy based on target
    case target
    when "app_store"
      deploy_to_app_store
    when "testflight_beta"
      deploy_to_testflight_beta
    when "testflight_internal"
      deploy_to_testflight_internal
    else
      UI.user_error!("‚ùå Unknown target: #{target}")
    end
    
    UI.success("‚úÖ Successfully deployed to #{target}!")
  end
  
  # üîç NEW: IPA Validation with detailed logging
  private_lane :validate_ipa_build do
    ipa_path = "build/Runner.ipa"
    
    UI.header("üîç IPA BUILD VALIDATION")
    
    unless File.exist?(ipa_path)
      UI.user_error!("‚ùå IPA file not found at: #{ipa_path}")
    end
    
    # File size check
    ipa_size = (File.size(ipa_path) / 1024.0 / 1024.0).round(2)
    UI.message("üì¶ IPA Size: #{ipa_size} MB")
    
    # Extract and inspect IPA contents
    UI.message("üîì Extracting IPA for inspection...")
    
    begin
      # Create temp directory
      temp_dir = "build/ipa_inspection"
      sh("rm -rf #{temp_dir} && mkdir -p #{temp_dir}")
      sh("cd #{temp_dir} && unzip -q ../Runner.ipa")
      
      app_path = "#{temp_dir}/Payload/Runner.app"
      
      if File.exist?(app_path)
        UI.success("‚úÖ App bundle found")
        
        # üîç CHECK PROVISIONING PROFILE
        UI.message("üìã Checking provisioning profile...")
        mobileprovision_path = "#{app_path}/embedded.mobileprovision"
        
        if File.exist?(mobileprovision_path)
          # Decode provisioning profile
          profile_content = sh("security cms -D -i '#{mobileprovision_path}' 2>/dev/null || echo 'Failed to decode'", log: false).strip
          
          if profile_content != "Failed to decode"
            # Parse key information
            if profile_content.include?("<key>get-task-allow</key>")
              is_development = profile_content.include?("<key>get-task-allow</key>\n\t<true/>")
              UI.message("   Profile Type: #{is_development ? 'üü° Development' : 'üü¢ Distribution'}")
            end
            
            # Extract team ID
            if match = profile_content.match(/<string>([A-Z0-9]{10})\.[^<]+<\/string>/)
              team_id = match[1]
              UI.message("   Team ID: #{team_id}")
            end
            
            # Extract app identifier
            if match = profile_content.match(/<key>application-identifier<\/key>\s*<string>([^<]+)<\/string>/)
              app_id = match[1]
              UI.message("   App ID: #{app_id}")
            end
            
            # Check expiration
            if match = profile_content.match(/<key>ExpirationDate<\/key>\s*<date>([^<]+)<\/date>/)
              expiry = match[1]
              UI.message("   Expires: #{expiry}")
            end
            
          else
            UI.error("‚ùå Failed to decode provisioning profile")
          end
        else
          UI.error("‚ùå No embedded provisioning profile found")
        end
        
        # üîç CHECK CODE SIGNING
        UI.message("üîê Checking code signing...")
        begin
          codesign_info = sh("codesign -dv --verbose=4 '#{app_path}' 2>&1", log: false)
          
          codesign_info.each_line do |line|
            line = line.strip
            if line.include?("Authority=") || line.include?("TeamIdentifier=") || line.include?("Identifier=")
              UI.message("   #{line}")
            end
          end
          
          # Verify signature
          verification = sh("codesign --verify --verbose '#{app_path}' 2>&1 || echo 'VERIFICATION_FAILED'", log: false).strip
          
          if verification.include?("VERIFICATION_FAILED")
            UI.error("‚ùå Code signing verification failed")
          else
            UI.success("‚úÖ Code signing verification passed")
          end
          
        rescue => e
          UI.error("‚ùå Error checking code signing: #{e.message}")
        end
        
        # üîç CHECK INFO.PLIST
        UI.message("üìÑ Checking Info.plist...")
        info_plist_path = "#{app_path}/Info.plist"
        
        if File.exist?(info_plist_path)
          begin
            bundle_id = sh("plutil -extract CFBundleIdentifier '#{info_plist_path}' -raw 2>/dev/null || echo 'unknown'", log: false).strip
            bundle_version = sh("plutil -extract CFBundleShortVersionString '#{info_plist_path}' -raw 2>/dev/null || echo 'unknown'", log: false).strip
            build_number = sh("plutil -extract CFBundleVersion '#{info_plist_path}' -raw 2>/dev/null || echo 'unknown'", log: false).strip
            
            UI.message("   Bundle ID: #{bundle_id}")
            UI.message("   Version: #{bundle_version}")
            UI.message("   Build: #{build_number}")
          rescue => e
            UI.error("‚ùå Error reading Info.plist: #{e.message}")
          end
        end
        
      else
        UI.error("‚ùå App bundle not found in IPA")
      end
      
      # Cleanup
      sh("rm -rf #{temp_dir}")
      
    rescue => e
      UI.error("‚ùå Error during IPA validation: #{e.message}")
    end
    
    UI.message("üîç IPA validation completed")
  end
  
  # üîß Helper method ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á App Store Connect API key object
  private_lane :create_api_key_object do
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    UI.header("üîë APP STORE CONNECT API KEY SETUP")
    
    # üîç LOG API KEY STATUS
    UI.message("üìã API Key Configuration:")
    UI.message("   Key ID: #{api_key_id ? "#{api_key_id[0..7]}..." : '‚ùå Missing'}")
    UI.message("   Issuer ID: #{api_issuer_id ? "#{api_issuer_id[0..7]}..." : '‚ùå Missing'}")
    UI.message("   Key Content: #{api_key_content_base64 ? "‚úÖ Available (#{api_key_content_base64.length} chars)" : '‚ùå Missing'}")
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        require 'base64'
        
        # üîç VALIDATE BASE64 CONTENT
        UI.message("üîç Validating API key content...")
        
        begin
          api_key_content = Base64.decode64(api_key_content_base64)
          UI.message("   Decoded length: #{api_key_content.length} characters")
          
          # Check if it looks like a valid P8 key
          if api_key_content.include?("BEGIN PRIVATE KEY") && api_key_content.include?("END PRIVATE KEY")
            UI.success("‚úÖ API key content appears to be valid P8 format")
          else
            UI.error("‚ùå API key content doesn't appear to be valid P8 format")
            UI.message("   First 50 chars: #{api_key_content[0..49]}")
          end
          
        rescue => decode_error
          UI.error("‚ùå Failed to decode base64 content: #{decode_error.message}")
          return nil
        end
        
        UI.message("‚úÖ Creating App Store Connect API configuration")
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á App Store Connect API object
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,
          duration: 1200, # 20 minutes
          in_house: false
        }
        
        # üîç TEST API KEY VALIDITY
        UI.message("üß™ Testing API key validity...")
        test_api_key_access(app_store_connect_api_key)
        
        UI.success("‚úÖ App Store Connect API key object created successfully")
        app_store_connect_api_key
        
      rescue => e
        UI.error("‚ùå Failed to create API key object: #{e.message}")
        UI.error("   Error class: #{e.class}")
        UI.error("   Backtrace: #{e.backtrace.first(3).join(', ')}")
        UI.message("‚ö†Ô∏è Will use traditional auth")
        nil
      end
    else
      UI.error("‚ö†Ô∏è API key not available, using traditional auth")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_content_base64
      UI.message("Missing: #{missing_items.join(', ')}")
      nil
    end
  end
  
  # üîç NEW: Test API key access
  private_lane :test_api_key_access do |api_key_object|
    begin
      UI.message("üîç Testing API access with xcrun altool...")
      
      # Create temporary key file for testing
      temp_key_file = "/tmp/test_api_key.p8"
      File.write(temp_key_file, api_key_object[:key])
      
      # Set environment for altool
      ENV['API_PRIVATE_KEYS_DIR'] = '/tmp'
      
      # Test basic API access
      result = sh(
        "xcrun altool --list-apps --apiKey #{api_key_object[:key_id]} --apiIssuer #{api_key_object[:issuer_id]} -t ios 2>&1 || echo 'API_TEST_FAILED'",
        log: false
      ).strip
      
      if result.include?("API_TEST_FAILED")
        UI.error("‚ùå API key test failed")
        UI.message("   Result: #{result}")
      elsif result.include?("No Applications found")
        UI.message("‚ö†Ô∏è No applications found (API key works but no apps)")
      else
        UI.success("‚úÖ API key test successful")
        UI.message("   Found applications")
      end
      
      # Cleanup
      File.delete(temp_key_file) if File.exist?(temp_key_file)
      
    rescue => e
      UI.message("‚ö†Ô∏è API key test error: #{e.message}")
    end
  end
  
  # üîß Helper method ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö setup certificates ‡∏û‡∏£‡πâ‡∏≠‡∏° API key
  private_lane :setup_certificates_with_api_key do |options|
    readonly_mode = options[:readonly] || true
    cert_type = options[:type] || "appstore"
    
    UI.header("üîê CERTIFICATES & PROVISIONING SETUP")
    UI.message("   Type: #{cert_type}")
    UI.message("   Readonly: #{readonly_mode}")
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á match options
    match_options = {
      type: cert_type,
      readonly: readonly_mode,
      verbose: true  # üîç Enable verbose logging
    }
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏° API key ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    api_key_object = create_api_key_object
    if api_key_object
      match_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for Match authentication")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for Match (requires FASTLANE_PASSWORD)")
    end
    
    # ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ match
    begin
      match(match_options)
      UI.success("‚úÖ Certificates setup completed!")
    rescue => e
      UI.error("‚ùå Match failed: #{e.message}")
      
      # üîç ENHANCED ERROR LOGGING
      UI.message("üîç Match error details:")
      UI.message("   Error class: #{e.class}")
      UI.message("   Backtrace: #{e.backtrace.first(5).join("\n   ")}")
      
      # Check common issues
      if e.message.include?("git")
        UI.message("üí° This appears to be a Git-related error")
      elsif e.message.include?("certificate")
        UI.message("üí° This appears to be a certificate-related error")
      elsif e.message.include?("profile")
        UI.message("üí° This appears to be a provisioning profile error")
      end
      
      raise e
    end
  end
  
  # üîß Enhanced TestFlight upload with detailed logging
  private_lane :deploy_to_testflight_internal do
    UI.header("üîí TESTFLIGHT INTERNAL UPLOAD")
    
    # üîç PRE-UPLOAD CHECKS
    ipa_path = "build/Runner.ipa"
    unless File.exist?(ipa_path)
      UI.user_error!("‚ùå IPA file not found: #{ipa_path}")
    end
    
    UI.message("üì¶ IPA file: #{ipa_path}")
    UI.message("üì¶ IPA size: #{(File.size(ipa_path) / 1024.0 / 1024.0).round(2)} MB")
    
    upload_options = {
      ipa: ipa_path,
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Internal testing build - #{Time.now.strftime('%Y-%m-%d %H:%M')}",
      skip_waiting_for_build_processing: true,
      skip_submission: true  # üîç ‡πÄ‡∏û‡∏¥‡πà‡∏° option ‡∏ô‡∏µ‡πâ
    }
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏° API key
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for TestFlight Internal upload")
      
      # üîç LOG UPLOAD OPTIONS
      UI.message("üìã Upload configuration:")
      upload_options.each do |key, value|
        next if key == :api_key  # Don't log sensitive data
        UI.message("   #{key}: #{value}")
      end
      
    else
      UI.message("‚ö†Ô∏è Using traditional auth for TestFlight Internal upload")
    end
    
    # üîç ENHANCED UPLOAD WITH ERROR HANDLING
    begin
      UI.message("üöÄ Starting upload to TestFlight...")
      UI.message("‚è±Ô∏è Upload started at: #{Time.now}")
      
      upload_to_testflight(upload_options)
      
      UI.success("‚úÖ Upload completed successfully!")
      UI.message("‚è±Ô∏è Upload finished at: #{Time.now}")
      
    rescue => upload_error
      UI.header("‚ùå TESTFLIGHT UPLOAD FAILED")
      UI.error("Error: #{upload_error.message}")
      UI.error("Class: #{upload_error.class}")
      
      # üîç DETAILED ERROR ANALYSIS
      error_message = upload_error.message.downcase
      
      if error_message.include?("altool")
        UI.message("üîç This is an altool-related error")
        
        if error_message.include?("object cannot be nil")
          UI.message("üí° Possible causes:")
          UI.message("   ‚Ä¢ API key doesn't have TestFlight permissions")
          UI.message("   ‚Ä¢ App not properly configured in App Store Connect")
          UI.message("   ‚Ä¢ Team ID mismatch between certificate and API key")
          UI.message("   ‚Ä¢ altool version compatibility issue")
        end
        
        if error_message.include?("1010")
          UI.message("üí° Error code 1010 suggests:")
          UI.message("   ‚Ä¢ Invalid API key configuration")
          UI.message("   ‚Ä¢ Missing required metadata in IPA")
          UI.message("   ‚Ä¢ App Store Connect setup incomplete")
        end
      end
      
      # Log environment info for debugging
      UI.message("üîç Environment info:")
      UI.message("   Xcode version: #{`xcodebuild -version`.split("\n").first}")
      UI.message("   Fastlane version: #{Fastlane::VERSION}")
      UI.message("   Ruby version: #{RUBY_VERSION}")
      
      # Show recent altool logs if available
      altool_logs = `find ~/Library/Logs -name "*altool*" -mtime -1 2>/dev/null | head -5`
      if !altool_logs.empty?
        UI.message("üîç Recent altool logs found:")
        altool_logs.split("\n").each { |log| UI.message("   #{log}") }
      end
      
      raise upload_error
    end
  end
  
  # Add other lanes with similar enhanced logging...
  private_lane :deploy_to_testflight_beta do
    # Similar structure with enhanced logging
  end
  
  private_lane :deploy_to_app_store do
    # Similar structure with enhanced logging  
  end
  
  # Enhanced error handling
  error do |lane, exception|
    UI.header("‚ùå FASTLANE ERROR")
    UI.error("Lane: #{lane}")
    UI.error("Error: #{exception.message}")
    UI.error("Class: #{exception.class}")
    
    # üîç LOG FULL BACKTRACE FOR DEBUGGING
    UI.message("üîç Full backtrace:")
    exception.backtrace.each_with_index do |line, index|
      UI.message("   #{index}: #{line}")
      break if index > 10  # Limit to first 10 lines
    end
    
    # Clean up build artifacts on error
    if File.exist?("build")
      UI.message("üßπ Cleaning up build artifacts...")
      sh("rm -rf build")
    end
    
    if ENV['CI']
      UI.message("üìã Fastlane logs available in artifacts")
    end
    
    # üîç LOG ENVIRONMENT STATE
    UI.message("üîç Environment state:")
    UI.message("   PWD: #{Dir.pwd}")
    UI.message("   Files in current dir: #{Dir.glob('*').join(', ')}")
    if File.exist?("build")
      UI.message("   Files in build dir: #{Dir.glob('build/*').join(', ')}")
    end
  end
end