# ios/fastlane/Fastfile - Standardized for all platforms
default_platform(:ios)

platform :ios do

  #Setup ‡πÅ‡∏•‡∏∞ Configuration
  before_all do
    ENV["FASTLANE_SKIP_UPDATE_CHECK"] = "1"
    setup_ci if ENV['CI']
    apply_version_from_env if ENV['CI']
  end

  #Version Management
  private_lane :apply_version_from_env do
    version_name = ENV['VERSION_NAME'] || "1.0.0"
    version_code = ENV['VERSION_CODE'] || "1"
    
    UI.message("üìã Applying version from GitHub Actions workflow:")
    UI.message("   CFBundleShortVersionString: #{version_name}")
    UI.message("   CFBundleVersion: #{version_code}")
    UI.message("   Source: GitHub Actions (#{ENV['GITHUB_REF_NAME']})")
    
    increment_version_number(version_number: version_name)
    increment_build_number(build_number: version_code)
    
    UI.success("‚úÖ Version applied from GitHub Actions")
  end

  #‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Deployment TestFlight Internal
  lane :deploy_develop do 
    UI.message("üöÄ Deploying to TestFlight Internal...")
    build_and_deploy(
      groups: ["Internal Testers", "Developers"],
      skip_waiting: true
    )
  end

  #‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Deployment TestFlight Beta
  lane :deploy_preprod do
    UI.message("üöÄ Deploying to TestFlight Beta...")
    build_and_deploy(
      groups: ["Beta Testers", "QA Team"],
      skip_waiting: false
    )
  end

  #‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Deployment App Store
  lane :deploy_master do
    UI.message("üéâ Deploying to App Store...")
    setup_certificates
    build_release_app
    
    upload_options = {
      force: true,
      submit_for_review: false,
      automatic_release: false,
      skip_metadata: true,
      skip_screenshots: true,
      precheck_include_in_app_purchases: false
    }
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ API key object ‡πÅ‡∏ó‡∏ô path
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using API key for App Store upload")
    else
      UI.message("‚ö†Ô∏è API key not available for App Store upload, using traditional auth")
    end
    
    upload_to_app_store(upload_options)
  end

  #‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Build ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà deploy
  lane :build_only do
    UI.message("üî® Building iOS app...")
    setup_certificates
    build_release_app
    UI.success("‚úÖ iOS build completed successfully!")
  end
  
  #‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ certificates
  private_lane :setup_certificates do
    UI.message("üîê Setting up certificates...")
    
    match_options = {
      type: "appstore",
      readonly: true
    }
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏° API key ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    api_key_object = create_api_key_object
    if api_key_object
      match_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for Match authentication")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for Match (requires FASTLANE_PASSWORD)")
    end
    
    match(match_options)
    UI.success("‚úÖ Certificates setup completed")
  end

  #Build app
  private_lane :build_release_app do
    # Build Flutter iOS (without codesign - Fastlane will handle it)
    version = ENV['VERSION_NAME'] || "1.0.0"
    build_number = ENV['VERSION_CODE'] || "1"
    
    sh("cd .. && flutter build ios --release --no-codesign --build-name=#{version} --build-number=#{build_number}")
    
    # Build and archive with Xcode
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "build",
      output_name: "Runner.ipa",
      clean: true
    )
  end

  #Core deployment logic
  private_lane :build_and_deploy do |options|
    setup_certificates
    build_release_app
    
    upload_options = {
      skip_waiting_for_build_processing: options[:skip_waiting],
      groups: options[:groups],
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Automated build from #{ENV['GITHUB_REF_NAME']} branch"
    }
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ API key object ‡πÅ‡∏ó‡∏ô path
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for TestFlight upload")
    else
      UI.message("‚ö†Ô∏è API key not available for TestFlight upload, using traditional auth")
    end

    # --- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ ---
    # ‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤ api_key_path ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏´‡∏•‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏°‡∏≤ ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô conflict ‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï
    upload_options[:api_key_path] = nil
    # -------------------------------------
    
    upload_to_testflight(upload_options)
  end
  
  #‡∏™‡∏£‡πâ‡∏≤‡∏á App Store Connect API key object
  private_lane :create_api_key_object do
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        require 'base64'
        api_key_content = Base64.decode64(api_key_content_base64)
        
        UI.message("‚úÖ Creating App Store Connect API configuration")
        UI.message("   Key ID: #{api_key_id}")
        UI.message("   Issuer ID: #{api_issuer_id}")
        UI.message("   Content length: #{api_key_content.length} characters")
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á App Store Connect API object
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,
          duration: 1200, # 20 minutes
          in_house: false
        }
        
        UI.success("‚úÖ App Store Connect API key object created")
        app_store_connect_api_key
        
      rescue => e
        UI.error("‚ùå Failed to create API key object: #{e.message}")
        UI.error("   Error class: #{e.class}")
        UI.message("‚ö†Ô∏è Will use traditional auth")
        nil
      end
    else
      UI.message("‚ö†Ô∏è API key not available, using traditional auth")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_content_base64
      UI.message("Missing: #{missing_items.join(', ')}")
      nil
    end
  end

  #Error handling
  error do |lane, exception|
    error_message = "‚ùå iOS deployment failed in lane '#{lane}': #{exception.message}"
    UI.error(error_message)
    
    # Clean up build artifacts on error
    if File.exist?("build")
      UI.message("üßπ Cleaning up build artifacts...")
      sh("rm -rf build")
    end
    
    if ENV['CI']
      UI.message("üìã Fastlane logs available in artifacts")
    end
    
    raise exception
  end
end