# ios/fastlane/Fastfile - Enhanced with React Native workflow features
default_platform(:ios)

platform :ios do
  
  before_all do
    ENV["FASTLANE_SKIP_UPDATE_CHECK"] = "1"
    setup_ci if ENV['CI']
    ensure_bundle_exec
    auto_update_version if ENV['GITHUB_RUN_NUMBER']
  end

  # âœ¨ Auto version management à¸ªà¸³à¸«à¸£à¸±à¸š Flutter
  private_lane :auto_update_version do
    begin
      # à¸”à¸¶à¸‡ version à¸ˆà¸²à¸ pubspec.yaml
      pubspec_path = File.expand_path('../../pubspec.yaml')
      if File.exist?(pubspec_path)
        pubspec_content = File.read(pubspec_path)
        version_match = pubspec_content.match(/^version:\s*(.+)$/m)
        if version_match
          version_full = version_match[1].strip
          # à¹à¸¢à¸ version à¹à¸¥à¸° build number (format: 1.2.3+4)
          if version_full.include?('+')
            version_parts = version_full.split('+')
            new_version = version_parts[0]
            build_number = version_parts[1]
          else
            new_version = version_full
            build_number = ENV['GITHUB_RUN_NUMBER'] || "1"
          end
        else
          UI.error("Version not found in pubspec.yaml, using default")
          new_version = "1.0.0"
          build_number = ENV['GITHUB_RUN_NUMBER'] || "1"
        end
      else
        UI.error("pubspec.yaml not found, using default version")
        new_version = "1.0.0"
        build_number = ENV['GITHUB_RUN_NUMBER'] || "1"
      end
      
      branch = ENV['GITHUB_REF_NAME'] || 'develop'
      
      # à¸­à¸±à¸à¹€à¸”à¸— iOS version à¹ƒà¸™ Xcode project
      increment_version_number(
        version_number: new_version,
        xcodeproj: "Runner.xcodeproj"
      )
      
      increment_build_number(
        build_number: build_number,
        xcodeproj: "Runner.xcodeproj"
      )
      
      UI.success("âœ… Auto updated iOS version from pubspec.yaml:")
      UI.success("   CFBundleShortVersionString: #{new_version}")
      UI.success("   CFBundleVersion: #{build_number}")
      UI.success("   branch: #{branch}")
      
    rescue => e
      UI.error("âŒ Failed to auto update version: #{e.message}")
      UI.error("Continuing with existing version...")
    end
  end

  # âœ¨ Manual version management
  lane :set_version do |options|
    version = options[:version] || prompt(text: "Enter version (e.g., 1.2.3):")
    build = options[:build] || prompt(text: "Enter build number (e.g., 123):")
    
    increment_version_number(
      version_number: version,
      xcodeproj: "Runner.xcodeproj"
    )
    
    increment_build_number(
      build_number: build,
      xcodeproj: "Runner.xcodeproj"
    )
    
    # à¸­à¸±à¸à¹€à¸”à¸— pubspec.yaml à¸”à¹‰à¸§à¸¢
    update_pubspec_version(version: version, build: build)
    
    UI.success("âœ… Manually set version:")
    UI.success("   iOS CFBundleShortVersionString: #{version}")
    UI.success("   iOS CFBundleVersion: #{build}")
    UI.success("   pubspec.yaml updated")
  end

  lane :bump_version do |options|
    type = options[:type] || "patch"
    
    # à¸­à¹ˆà¸²à¸™ version à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™à¸ˆà¸²à¸ iOS project
    current_version = get_version_number(xcodeproj: "Runner.xcodeproj")
    current_build = get_build_number(xcodeproj: "Runner.xcodeproj").to_i
    
    # Parse semantic version
    version_parts = current_version.split('.').map(&:to_i)
    
    case type
    when "major"
      version_parts[0] += 1
      version_parts[1] = 0
      version_parts[2] = 0
    when "minor"
      version_parts[1] += 1
      version_parts[2] = 0
    when "patch"
      version_parts[2] += 1
    end
    
    new_version = version_parts.join('.')
    new_build = current_build + 1
    
    increment_version_number(
      version_number: new_version,
      xcodeproj: "Runner.xcodeproj"
    )
    
    increment_build_number(
      build_number: new_build.to_s,
      xcodeproj: "Runner.xcodeproj"
    )
    
    # à¸­à¸±à¸à¹€à¸”à¸— pubspec.yaml à¸”à¹‰à¸§à¸¢
    update_pubspec_version(version: new_version, build: new_build.to_s)
    
    UI.success("âœ… Bumped #{type} version:")
    UI.success("   #{current_version} -> #{new_version}")
    UI.success("   build: #{current_build} -> #{new_build}")
  end

  # ğŸš€ Main deployment lane
  desc "Deploy to App Store Connect"
  lane :deploy do |options|
    target = options[:target] || "testflight_internal"
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("ğŸ Building and deploying Flutter iOS")
    UI.message("ğŸ¯ Target: #{target}")
    UI.message("ğŸ“‹ Version: #{version} (#{build_number})")
    
    # Setup certificates and provisioning profiles with Match
    setup_certificates
    
    # Update version numbers
    increment_version_number(version_number: version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter iOS
    build_flutter_ios(version: version, build_number: build_number)
    
    # Build and archive with Xcode
    build_ios_app
    
    # Deploy based on target
    case target
    when "app_store"
      deploy_to_app_store
    when "testflight_beta"
      deploy_to_testflight_beta
    when "testflight_internal"
      deploy_to_testflight_internal
    else
      UI.user_error!("âŒ Unknown target: #{target}")
    end
    
    UI.success("âœ… Successfully deployed to #{target}!")
  end

  # ğŸ”§ Helper method à¸ªà¸³à¸«à¸£à¸±à¸šà¸ªà¸£à¹‰à¸²à¸‡ App Store Connect API key object
  private_lane :create_api_key_object do
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        require 'base64'
        api_key_content = Base64.decode64(api_key_content_base64)
        
        UI.message("âœ… Creating App Store Connect API configuration")
        UI.message("   Key ID: #{api_key_id}")
        UI.message("   Issuer ID: #{api_issuer_id}")
        UI.message("   Content length: #{api_key_content.length} characters")
        
        # à¸ªà¸£à¹‰à¸²à¸‡ App Store Connect API object
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,
          duration: 1200, # 20 minutes
          in_house: false
        }
        
        UI.success("âœ… App Store Connect API key object created")
        return app_store_connect_api_key
        
      rescue => e
        UI.error("âŒ Failed to create API key object: #{e.message}")
        UI.error("   Error class: #{e.class}")
        UI.message("âš ï¸ Will use traditional auth")
        return nil
      end
    else
      UI.message("âš ï¸ API key not available, using traditional auth")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_content_base64
      UI.message("Missing: #{missing_items.join(', ')}")
      return nil
    end
  end

  # ğŸ”§ Enhanced certificates setup
  private_lane :setup_certificates do
    UI.message("ğŸ” Setting up certificates...")
    
    begin
      match(
        type: "appstore",
        readonly: false,
        git_url: ENV['MATCH_GIT_URL'],
        app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
      )
      
      UI.success("âœ… Certificates setup completed")
    rescue => e
      UI.error("âŒ Failed to setup certificates: #{e.message}")
      
      # à¸à¸¢à¸²à¸¢à¸²à¸¡ readonly mode
      UI.message("ğŸ”„ Trying readonly mode...")
      match(
        type: "appstore",
        readonly: true,
        git_url: ENV['MATCH_GIT_URL'],
        app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
      )
      
      UI.success("âœ… Certificates setup completed (readonly)")
    end
  end

  # ğŸ”§ Enhanced Flutter build
  private_lane :build_flutter_ios do |options|
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("ğŸ”¨ Building Flutter iOS...")
    
    # Verify Flutter installation
    sh("flutter --version")
    
    # Clean previous builds
    sh("cd .. && flutter clean")
    
    # Get dependencies
    sh("cd .. && flutter pub get")
    
    # Build Flutter iOS (without codesign - Fastlane will handle it)
    build_command = [
      "cd ..",
      "flutter build ios",
      "--release",
      "--no-codesign",
      "--build-name=#{version}",
      "--build-number=#{build_number}"
    ].join(" && ")
    
    begin
      sh(build_command)
      UI.success("âœ… Flutter iOS build completed")
    rescue => e
      UI.error("âŒ Flutter build failed: #{e.message}")
      raise e
    end
  end

  # ğŸ”§ Enhanced iOS app build
  private_lane :build_ios_app do
    UI.message("ğŸ”¨ Building iOS app with Xcode...")
    
    begin
      build_app(
        workspace: "Runner.xcworkspace",
        scheme: "Runner",
        configuration: "Release",
        export_method: "app-store",
        output_directory: "build",
        output_name: "Runner.ipa",
        clean: true,
        silent: true,
        export_options: {
          method: "app-store",
          provisioningProfiles: {
            CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier) => 
              "match AppStore #{CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)}"
          }
        }
      )
      
      # Verify build
      ipa_path = "build/Runner.ipa"
      if File.exist?(ipa_path)
        file_size = (File.size(ipa_path) / 1024.0 / 1024.0).round(2)
        UI.success("âœ… iOS app built successfully: #{file_size} MB")
      else
        UI.error("âŒ IPA file not found at: #{ipa_path}")
        raise "Build failed - IPA not created"
      end
      
    rescue => e
      UI.error("âŒ iOS app build failed: #{e.message}")
      raise e
    end
  end

  # ğŸ”§ Deployment methods with enhanced API key support
  private_lane :deploy_to_app_store do
    UI.message("ğŸª Uploading to App Store...")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false,
      automatic_release: false,
      force: true,
      precheck_include_in_app_purchases: false
    }
    
    # âœ… à¹ƒà¸Šà¹‰ API key object à¹à¸—à¸™ traditional auth
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("âœ… Using App Store Connect API for App Store upload")
    else
      UI.message("âš ï¸ Using traditional auth for App Store upload")
    end
    
    upload_to_app_store(upload_options)
    UI.success("âœ… App Store upload completed!")
  end
  
  private_lane :deploy_to_testflight_beta do
    UI.message("âœˆï¸ Uploading to TestFlight (Beta)...")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      groups: ["Beta Testers"],
      distribute_external: true,
      notify_external_testers: true,
      changelog: "Beta release - please test and provide feedback",
      skip_waiting_for_build_processing: false
    }
    
    # âœ… à¹ƒà¸Šà¹‰ API key object
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("âœ… Using App Store Connect API for TestFlight Beta upload")
    else
      UI.message("âš ï¸ Using traditional auth for TestFlight Beta upload")
    end
    
    upload_to_testflight(upload_options)
    UI.success("âœ… TestFlight Beta upload completed!")
  end
  
  private_lane :deploy_to_testflight_internal do
    UI.message("ğŸ”’ Uploading to TestFlight (Internal)...")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Internal testing build",
      skip_waiting_for_build_processing: true
    }
    
    # âœ… à¹ƒà¸Šà¹‰ API key object
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("âœ… Using App Store Connect API for TestFlight Internal upload")
    else
      UI.message("âš ï¸ Using traditional auth for TestFlight Internal upload")
    end
    
    upload_to_testflight(upload_options)
    UI.success("âœ… TestFlight Internal upload completed!")
  end

  # ğŸ”§ Convenience lanes for specific branches
  desc "Deploy to App Store (main branch)"
  lane :deploy_production do
    deploy(target: "app_store")
  end
  
  desc "Deploy to TestFlight Beta (staging branch)"
  lane :deploy_staging do
    deploy(target: "testflight_beta")
  end
  
  desc "Deploy to TestFlight Internal (develop branch)"
  lane :deploy_development do
    deploy(target: "testflight_internal")
  end

  # ğŸ”§ Build-only lane (no deployment)
  desc "Build only (no deploy)"
  lane :build_only do |options|
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("ğŸ”¨ Building Flutter iOS app...")
    UI.message("ğŸ“‹ Version: #{version} (#{build_number})")
    
    # Setup certificates
    setup_certificates
    
    # Update version
    increment_version_number(version_number: version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter
    build_flutter_ios(version: version, build_number: build_number)
    
    # Build iOS app
    build_ios_app
    
    UI.success("âœ… Flutter iOS build completed!")
  end
  
  desc "Setup certificates only"
  lane :setup_certificates_only do
    setup_certificates
    UI.success("âœ… Certificates setup completed!")
  end

  # ğŸ”§ Submit for review lane with API key support
  desc "Submit for App Store review"
  lane :submit_for_review do
    UI.message("ğŸ“‹ Submitting for App Store review...")
    
    upload_options = {
      skip_binary_upload: true,
      submit_for_review: true,
      automatic_release: false,
      force: true,
      submission_information: submission_info
    }
    
    # âœ… à¹ƒà¸Šà¹‰ API key object
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("âœ… Using App Store Connect API for review submission")
    else
      UI.message("âš ï¸ Using traditional auth for review submission")
    end
    
    upload_to_app_store(upload_options)
    UI.success("âœ… App submitted for review!")
  end

  # ğŸ”§ Helper method à¸ªà¸³à¸«à¸£à¸±à¸šà¸­à¸±à¸à¹€à¸”à¸— pubspec.yaml
  private_lane :update_pubspec_version do |options|
    version = options[:version]
    build = options[:build]
    
    pubspec_path = File.expand_path('../../pubspec.yaml')
    if File.exist?(pubspec_path)
      content = File.read(pubspec_path)
      new_content = content.gsub(/^version:\s*.*$/m, "version: #{version}+#{build}")
      File.write(pubspec_path, new_content)
      UI.success("âœ… Updated pubspec.yaml version to #{version}+#{build}")
    else
      UI.error("âŒ pubspec.yaml not found")
    end
  end

  # ğŸ”§ Submission information for App Store review
  private_lane :submission_info do
    {
      add_id_info_limits_tracking: true,
      add_id_info_serves_ads: false,
      add_id_info_tracks_action: true,
      add_id_info_tracks_install: true,
      add_id_info_uses_idfa: true,
      content_rights_has_rights: true,
      content_rights_contains_third_party_content: true,
      export_compliance_platform: 'ios',
      export_compliance_compliance_required: false,
      export_compliance_encryption_updated: false,
      export_compliance_uses_encryption: false,
      export_compliance_is_exempt: false,
      export_compliance_contains_third_party_cryptography: false,
      export_compliance_contains_proprietary_cryptography: false,
      export_compliance_available_on_french_store: false
    }
  end

  # ğŸ”§ Notification helper (à¸ªà¸³à¸«à¸£à¸±à¸š Slack à¸«à¸£à¸·à¸­ Teams)
  private_lane :notify_deployment do |message|
    return unless ENV["SLACK_URL"]
    
    begin
      slack(
        message: message,
        channel: "#releases",
        webhook_url: ENV["SLACK_URL"],
        username: "Flutter iOS CI/CD",
        icon_emoji: ":flutter:"
      )
    rescue => e
      UI.error("Failed to send notification: #{e.message}")
    end
  end

  # Error handling
  error do |lane, exception|
    error_message = "âŒ Flutter iOS deployment failed in lane '#{lane}': #{exception.message}"
    UI.error(error_message)
    
    # Clean up build artifacts on error
    if File.exist?("build")
      UI.message("ğŸ§¹ Cleaning up build artifacts...")
      sh("rm -rf build")
    end
    
    # Clean Flutter build
    sh("cd .. && flutter clean") rescue nil
    
    if ENV['CI']
      UI.message("ğŸ“‹ Fastlane logs available in artifacts")
    end
    
    # notify_deployment(error_message) if defined?(notify_deployment)
    raise exception
  end
end