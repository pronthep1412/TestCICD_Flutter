# ios/fastlane/Fastfile - ‡∏â‡∏ö‡∏±‡∏ö‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡∏´‡∏•‡∏±‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
default_platform(:ios)

platform :ios do
  before_all do
    ENV["FASTLANE_SKIP_UPDATE_CHECK"] = "1"
    setup_ci if ENV['CI']
  end

  desc "Deploy to App Store Connect"
  lane :deploy do |options|
    target = options[:target] || "testflight_internal"
    raw_version = options[:version] || "67000.0.0"
    build_number = options[:build_number] || "1"
    original_version = options[:original_version] || raw_version
    
    # ‚úÖ Clean ‡πÅ‡∏•‡∏∞ validate version
    clean_version = validate_and_clean_version(version: raw_version)
    
    UI.message("üçé Building and deploying iOS")
    UI.message("üéØ Target: #{target}")
    UI.message("üìã Raw Version: #{raw_version}")
    UI.message("üìã Clean Version: #{clean_version} (#{build_number})")
    UI.message("üìã Original Version: #{original_version}") if original_version != clean_version
    
    # üîß Setup certificates and provisioning profiles
    setup_certificates_with_api_key
    
    # Update version numbers with clean version
    increment_version_number(version_number: clean_version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter iOS
    sh("cd .. && flutter build ios --release --no-codesign --build-name=#{clean_version} --build-number=#{build_number}")
    
    # Build and archive with Xcode
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "build",
      output_name: "Runner.ipa",
      silent: true
    )
    
    # Deploy based on target with retry mechanism
    case target
    when "app_store"
      deploy_to_app_store_with_retry(version: clean_version, original_version: original_version)
    when "testflight_beta"
      deploy_to_testflight_beta_with_retry(version: clean_version, original_version: original_version)
    when "testflight_internal"
      deploy_to_testflight_internal_with_retry(version: clean_version, original_version: original_version)
    else
      UI.user_error!("‚ùå Unknown target: #{target}")
    end
    
    UI.success("‚úÖ Successfully deployed to #{target}!")
    UI.success("üìã Version deployed: #{clean_version} (build #{build_number})")
  end
  
  # üîß Enhanced: Validate ‡πÅ‡∏•‡∏∞ clean version format for App Store
  private_lane :validate_and_clean_version do |options|
    version = options[:version] || "67000.0.0"
    UI.message("üîç Validating and cleaning version: #{version}")
    
    # Remove any whitespace
    clean_version = version.to_s.strip
    original_input = clean_version
    
    # Pattern matching ‡πÅ‡∏•‡∏∞ cleaning
    case clean_version
    when /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/
      # 4-part version: X.Y.Z.W -> X.Y.Z
      major, minor, patch, build_part = $1, $2, $3, $4
      clean_version = "#{major}.#{minor}.#{patch}"
      UI.message("‚ö†Ô∏è 4-part version detected: #{original_input} ‚Üí #{clean_version}")
      UI.message("üí° Build part (#{build_part}) ignored for App Store compliance")
      
    when /^(\d+\.\d+\.\d+)-(alpha|beta|rc)\.?(\d+)?$/
      # Pre-release version: X.Y.Z-pre.N -> X.Y.Z
      base_version, prerelease, number = $1, $2, $3
      clean_version = base_version
      UI.message("‚ö†Ô∏è Pre-release version detected: #{original_input} ‚Üí #{clean_version}")
      UI.message("üí° Pre-release identifier (#{prerelease}) removed for App Store compliance")
      
    when /^(\d+)\.(\d+)$/
      # 2-part version: X.Y -> X.Y.0
      major, minor = $1, $2
      clean_version = "#{major}.#{minor}.0"
      UI.message("‚ö†Ô∏è 2-part version detected: #{original_input} ‚Üí #{clean_version}")
      
    when /^(\d+)$/
      # 1-part version: X -> X.0.0
      major = $1
      clean_version = "#{major}.0.0"
      UI.message("‚ö†Ô∏è 1-part version detected: #{original_input} ‚Üí #{clean_version}")
      
    when /^\d+\.\d+\.\d+$/
      # Already valid 3-part version
      UI.success("‚úÖ Version format is already valid: #{clean_version}")
      
    else
      # Invalid format - use smart fallback
      UI.error("‚ùå Invalid version format: #{version}")
      UI.error("üí° Supported formats: X.Y.Z, X.Y.Z.W, X.Y.Z-alpha.N")
      UI.error("üìù Using fallback version: 67000.0.0")
      clean_version = "67000.0.0"
    end
    
    # Final validation
    unless clean_version.match?(/^\d+\.\d+\.\d+$/)
      UI.error("‚ùå Final validation failed for: #{clean_version}")
      clean_version = "67000.0.0"
    end
    
    # Additional numeric validation ‡πÅ‡∏•‡∏∞ App Store compliance
    parts = clean_version.split('.')
    parts.each_with_index do |part, index|
      unless part.match?(/^\d+$/) && part.to_i >= 0
        UI.error("‚ùå Invalid version part at position #{index}: #{part}")
        clean_version = "67000.0.0"
        break
      end
    end
    
    # Check against minimum version (‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 66666.0.0)
    min_version = "66666.0.0"
    if version_compare(version1: clean_version, version2: min_version) <= 0
      UI.warning("‚ö†Ô∏è Version #{clean_version} is not greater than minimum #{min_version}")
      # Auto increment
      min_parts = min_version.split('.')
      new_patch = min_parts[2].to_i + 1
      clean_version = "#{min_parts[0]}.#{min_parts[1]}.#{new_patch}"
      UI.message("üîÑ Auto-incremented to: #{clean_version}")
    end
    
    UI.success("‚úÖ Final clean version: #{clean_version}")
    clean_version
  end
  
  # üîß Helper: Compare versions
  private_lane :version_compare do |options|
    version1 = options[:version1]
    version2 = options[:version2]
    
    return 0 if version1 == version2
    
    v1_parts = version1.split('.').map(&:to_i)
    v2_parts = version2.split('.').map(&:to_i)
    
    max_length = [v1_parts.length, v2_parts.length].max
    
    max_length.times do |i|
      v1 = v1_parts[i] || 0
      v2 = v2_parts[i] || 0
      
      return 1 if v1 > v2
      return -1 if v1 < v2
    end
    
    0
  end
  
  # üîß Helper method ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á App Store Connect API key object
  private_lane :create_api_key_object do
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        require 'base64'
        api_key_content = Base64.decode64(api_key_content_base64)
        
        UI.message("‚úÖ Creating App Store Connect API configuration")
        UI.message("   Key ID: #{api_key_id}")
        UI.message("   Issuer ID: #{api_issuer_id}")
        UI.message("   Content length: #{api_key_content.length} characters")
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á App Store Connect API object
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,
          duration: 1200, # 20 minutes
          in_house: false
        }
        
        UI.success("‚úÖ App Store Connect API key object created")
        app_store_connect_api_key
        
      rescue => e
        UI.error("‚ùå Failed to create API key object: #{e.message}")
        UI.error("   Error class: #{e.class}")
        UI.message("‚ö†Ô∏è Will use traditional auth")
        nil
      end
    else
      UI.message("‚ö†Ô∏è API key not available, using traditional auth")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_content_base64
      UI.message("Missing: #{missing_items.join(', ')}")
      nil
    end
  end
  
  # üîß Helper method ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö setup certificates ‡∏û‡∏£‡πâ‡∏≠‡∏° API key
  private_lane :setup_certificates_with_api_key do |options|
    readonly_mode = options[:readonly] || true
    cert_type = options[:type] || "appstore"
    
    UI.message("üîê Setting up certificates...")
    UI.message("   Type: #{cert_type}")
    UI.message("   Readonly: #{readonly_mode}")
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á match options
    match_options = {
      type: cert_type,
      readonly: readonly_mode
    }
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏° API key ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    api_key_object = create_api_key_object
    if api_key_object
      match_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for Match authentication")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for Match (requires FASTLANE_PASSWORD)")
    end
    
    # ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ match
    match(match_options)
    UI.success("‚úÖ Certificates setup completed!")
  end
  
  # üîß Enhanced deployment methods with retry mechanism
  private_lane :deploy_to_app_store_with_retry do |options|
    version = options[:version]
    original_version = options[:original_version]
    
    UI.message("üè™ Uploading to App Store...")
    
    changelog_text = create_changelog(version: version, original_version: original_version, prefix: "Release")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false,
      automatic_release: false,
      force: true,
      precheck_include_in_app_purchases: false
    }
    
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for App Store upload")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for App Store upload")
    end
    
    upload_with_retry(target: "app_store", upload_options: upload_options)
  end
  
  private_lane :deploy_to_testflight_beta_with_retry do |options|
    version = options[:version]
    original_version = options[:original_version]
    
    UI.message("‚úàÔ∏è Uploading to TestFlight (Beta)...")
    
    changelog_text = create_changelog(version: version, original_version: original_version, prefix: "Beta release")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      groups: ["Beta Testers"],
      distribute_external: true,
      notify_external_testers: true,
      changelog: changelog_text,
      skip_waiting_for_build_processing: false
    }
    
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for TestFlight Beta upload")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for TestFlight Beta upload")
    end
    
    upload_with_retry(target: "testflight", upload_options: upload_options)
  end
  
  private_lane :deploy_to_testflight_internal_with_retry do |options|
    version = options[:version]
    original_version = options[:original_version]
    
    UI.message("üîí Uploading to TestFlight (Internal)...")
    
    changelog_text = create_changelog(version: version, original_version: original_version, prefix: "Internal testing build")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      distribute_external: false,
      notify_external_testers: false,
      changelog: changelog_text,
      skip_waiting_for_build_processing: true
    }
    
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for TestFlight Internal upload")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for TestFlight Internal upload")
    end
    
    upload_with_retry(target: "testflight", upload_options: upload_options)
  end
  
  # üîß Helper: Create appropriate changelog
  private_lane :create_changelog do |options|
    version = options[:version]
    original_version = options[:original_version]
    prefix = options[:prefix]
    
    if original_version != version
      "#{prefix} #{original_version} (App Store version: #{version})"
    else
      "#{prefix} #{version}"
    end
  end
  
  # üîß Enhanced upload with retry mechanism
  private_lane :upload_with_retry do |options|
    target = options[:target]
    upload_options = options[:upload_options]
    
    max_retries = 3
    retry_delay = 30
    
    (1..max_retries).each do |attempt|
      begin
        UI.message("üöÄ Upload attempt #{attempt}/#{max_retries}")
        
        case target
        when "app_store"
          upload_to_app_store(upload_options)
        when "testflight"
          upload_to_testflight(upload_options)
        end
        
        UI.success("‚úÖ Upload successful on attempt #{attempt}")
        return
        
      rescue => e
        UI.error("‚ùå Upload attempt #{attempt} failed: #{e.message}")
        
        # Check for specific errors
        if e.message.include?("object cannot be nil") || e.message.include?("-1010")
          UI.error("üîç Detected altool nil object error")
          UI.error("üí° This usually indicates a version format issue")
          UI.error("üí° Current version format should be valid X.Y.Z")
          
        elsif e.message.include?("CFBundleShortVersionString")
          UI.error("üîç Version format error in Info.plist")
          UI.error("üí° App Store requires version format: X.Y.Z")
          
        elsif e.message.include?("version that is already being used")
          UI.error("üîç Version conflict detected")
          UI.error("üí° This version may already exist in App Store Connect")
          UI.error("üí° Try incrementing the version number")
          
        end
        
        if attempt < max_retries
          UI.message("‚è≥ Waiting #{retry_delay} seconds before retry...")
          sleep(retry_delay)
          retry_delay += 15  # Increase delay for next retry
        else
          UI.user_error!("‚ùå All upload attempts failed. Last error: #{e.message}")
        end
      end
    end
  end
  
  # Helper lanes for specific branches
  desc "Deploy to App Store (main branch)"
  lane :deploy_production do
    deploy(target: "app_store")
  end
  
  desc "Deploy to TestFlight Beta (staging branch)"
  lane :deploy_staging do
    deploy(target: "testflight_beta")
  end
  
  desc "Deploy to TestFlight Internal (develop branch)"
  lane :deploy_development do
    deploy(target: "testflight_internal")
  end
  
  # Debug/testing lanes
  desc "Build only (no deploy)"
  lane :build_only do |options|
    version = options[:version] || "67000.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("üî® Building iOS app...")
    UI.message("üìã Version: #{version} (#{build_number})")
    
    # ‚úÖ Clean ‡πÅ‡∏•‡∏∞ validate version
    clean_version = validate_and_clean_version(version: version)
    
    # üîß Setup certificates ‡∏û‡∏£‡πâ‡∏≠‡∏° API key
    setup_certificates_with_api_key(readonly: true)
    
    # Update version
    increment_version_number(version_number: clean_version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter
    sh("cd .. && flutter build ios --release --no-codesign --build-name=#{clean_version} --build-number=#{build_number}")
    
    # Build with Xcode
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "build",
      output_name: "Runner.ipa"
    )
    
    UI.success("‚úÖ iOS build completed!")
  end
  
  desc "Setup certificates only"
  lane :setup_certificates do |options|
    readonly_mode = options[:readonly] || true
    cert_type = options[:type] || "appstore"
    
    # üîß ‡πÉ‡∏ä‡πâ helper method ‡πÉ‡∏´‡∏°‡πà
    setup_certificates_with_api_key(readonly: readonly_mode, type: cert_type)
  end
  
  # üîß Test version cleaning utility
  desc "Test version format cleaning"
  lane :test_version_formats do
    test_versions = [
      "1.0.0.84",           # 4-part version
      "1.0.0-alpha.84",     # Pre-release
      "67000.0.0",          # Valid 3-part (new baseline)
      "2.1",                # 2-part
      "3",                  # 1-part
      "1.0.0-beta.5",       # Beta version
      "invalid.version",    # Invalid
      "1.2.3.4.5",         # Too many parts
      "66666.0.0",          # Equal to minimum (should increment)
      "66665.0.0",          # Less than minimum (should increment)
    ]
    
    UI.message("üß™ Testing version format cleaning...")
    test_versions.each do |version|
      UI.message("Input: #{version}")
      clean = validate_and_clean_version(version: version)
      UI.message("Output: #{clean}")
      UI.message("---")
    end
  end
  
  # üîß Submit for review lane with API key support
  desc "Submit for App Store review"
  lane :submit_for_review do
    UI.message("üìã Submitting for App Store review...")
    
    upload_options = {
      skip_binary_upload: true,
      submit_for_review: true,
      automatic_release: false,
      force: true,
      submission_information: submission_info
    }
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ API key object
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for review submission")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for review submission")
    end
    
    upload_to_app_store(upload_options)
    UI.success("‚úÖ App submitted for review!")
  end
  
  # üîß Submission information for App Store review
  private_lane :submission_info do
    {
      add_id_info_limits_tracking: true,
      add_id_info_serves_ads: false,
      add_id_info_tracks_action: true,
      add_id_info_tracks_install: true,
      add_id_info_uses_idfa: true,
      content_rights_has_rights: true,
      content_rights_contains_third_party_content: true,
      export_compliance_platform: 'ios',
      export_compliance_compliance_required: false,
      export_compliance_encryption_updated: false,
      export_compliance_uses_encryption: false,
      export_compliance_is_exempt: false,
      export_compliance_contains_third_party_cryptography: false,
      export_compliance_contains_proprietary_cryptography: false,
      export_compliance_available_on_french_store: false
    }
  end
  
  # üîß Enhanced error handling
  error do |lane, exception|
    UI.error("‚ùå Error in #{lane}: #{exception.message}")
    
    # Enhanced error diagnostics
    if exception.message.include?("CFBundleShortVersionString")
      UI.error("üîç Version format error detected!")
      UI.error("üí° App Store requires version format: X.Y.Z (e.g., 67000.0.0)")
      UI.error("üí° Remove any alpha/beta/rc suffixes from version string")
      UI.error("üí° Ensure version is greater than 66666.0.0")
      
    elsif exception.message.include?("object cannot be nil") || exception.message.include?("-1010")
      UI.error("üîç altool error detected!")
      UI.error("üí° This usually indicates a version format issue")
      UI.error("üí° Check Info.plist CFBundleShortVersionString value")
      UI.error("üí° Ensure version follows X.Y.Z format")
      
    elsif exception.message.include?("version that is already being used")
      UI.error("üîç Version conflict detected!")
      UI.error("üí° This version already exists in App Store Connect")
      UI.error("üí° Increment version number or build number")
      
    elsif exception.message.include?("Invalid binary")
      UI.error("üîç Binary validation error!")
      UI.error("üí° Check for missing architectures or invalid signatures")
      
    end
    
    # Clean up build artifacts on error
    if File.exist?("build")
      UI.message("üßπ Cleaning up build artifacts...")
      sh("rm -rf build")
    end
    
    if ENV['CI']
      UI.message("üìã Fastlane logs available in artifacts")
      UI.message("üí° Check GitHub Actions artifacts for detailed logs")
    end
    
    # Provide helpful suggestions
    UI.message("")
    UI.message("üí° Troubleshooting suggestions:")
    UI.message("   1. Verify version format is X.Y.Z")
    UI.message("   2. Ensure version > 66666.0.0")
    UI.message("   3. Check App Store Connect for conflicting versions")
    UI.message("   4. Verify certificates and provisioning profiles")
    UI.message("   5. Check API key configuration")
  end
end