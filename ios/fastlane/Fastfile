# ios/fastlane/Fastfile - Fixed API key file path issue
default_platform(:ios)

platform :ios do
  before_all do
    ENV["FASTLANE_SKIP_UPDATE_CHECK"] = "1"
    setup_ci if ENV['CI']
  end

  desc "Deploy to App Store Connect"
  lane :deploy do |options|
    target = options[:target] || "testflight_internal"
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("ğŸ Building and deploying iOS")
    UI.message("ğŸ¯ Target: #{target}")
    UI.message("ğŸ“‹ Version: #{version} (#{build_number})")
    
    # ğŸ”§ Setup certificates and provisioning profiles with Match + API Key
    setup_certificates_with_api_key
    
    # Update version numbers
    increment_version_number(version_number: version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter iOS (without codesign - Fastlane will handle it)
    sh("cd .. && flutter build ios --release --no-codesign --build-name=#{version} --build-number=#{build_number}")
    
    # Build and archive with Xcode
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "build",
      output_name: "Runner.ipa",
      silent: false  # Keep verbose for debugging
    )
    
    # ğŸ” IPA VALIDATION (FIXED PATH)
    validate_ipa_build
    
    # Deploy based on target
    case target
    when "app_store"
      deploy_to_app_store
    when "testflight_beta"
      deploy_to_testflight_beta
    when "testflight_internal"
      deploy_to_testflight_internal
    else
      UI.user_error!("âŒ Unknown target: #{target}")
    end
    
    UI.success("âœ… Successfully deployed to #{target}!")
  end
  
  # ğŸ” FIXED: IPA Validation with correct path
  private_lane :validate_ipa_build do
    # ğŸ”§ FIXED: Use full path from Lane Context
    ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH] || "build/Runner.ipa"
    
    UI.header("ğŸ” IPA BUILD VALIDATION")
    UI.message("ğŸ“¦ Checking IPA at: #{ipa_path}")
    
    unless File.exist?(ipa_path)
      # ğŸ” Debug: Show what files actually exist
      UI.message("ğŸ” Debug - Files in build directory:")
      if Dir.exist?("build")
        Dir.glob("build/*").each { |f| UI.message("   #{f}") }
      end
      
      # ğŸ” Try alternative paths
      alternative_paths = [
        "../build/Runner.ipa",
        "build/Runner.ipa", 
        "./build/Runner.ipa"
      ]
      
      found_path = alternative_paths.find { |path| File.exist?(path) }
      
      if found_path
        UI.message("âœ… Found IPA at alternative path: #{found_path}")
        ipa_path = found_path
      else
        UI.user_error!("âŒ IPA file not found. Checked paths: #{[ipa_path] + alternative_paths}")
      end
    end
    
    # File size check
    ipa_size = (File.size(ipa_path) / 1024.0 / 1024.0).round(2)
    UI.message("ğŸ“¦ IPA Size: #{ipa_size} MB")
    
    # Basic validation
    if File.size(ipa_path) > 10 * 1024 * 1024  # > 10MB
      UI.success("âœ… IPA size looks reasonable (#{ipa_size} MB)")
    else
      UI.error("âš ï¸ IPA size seems small (#{ipa_size} MB) - might be incomplete")
    end
    
    # Quick zip test
    begin
      result = sh("unzip -t '#{ipa_path}' >/dev/null 2>&1 && echo 'VALID' || echo 'INVALID'", log: false).strip
      if result == "VALID"
        UI.success("âœ… IPA zip structure is valid")
      else
        UI.error("âŒ IPA zip structure is corrupted")
      end
    rescue => e
      UI.message("âš ï¸ Could not validate IPA structure: #{e.message}")
    end
    
    UI.success("ğŸ” IPA validation completed")
  end
  
  # ğŸ”§ FIXED: Create API key file for altool compatibility
  private_lane :create_api_key_object do
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    UI.header("ğŸ”‘ APP STORE CONNECT API KEY SETUP")
    
    # ğŸ” LOG API KEY STATUS
    UI.message("ğŸ“‹ API Key Configuration:")
    UI.message("   Key ID: #{api_key_id ? "#{api_key_id[0..7]}..." : 'âŒ Missing'}")
    UI.message("   Issuer ID: #{api_issuer_id ? "#{api_issuer_id[0..7]}..." : 'âŒ Missing'}")
    UI.message("   Key Content: #{api_key_content_base64 ? "âœ… Available (#{api_key_content_base64.length} chars)" : 'âŒ Missing'}")
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        require 'base64'
        
        # ğŸ” VALIDATE BASE64 CONTENT
        UI.message("ğŸ” Validating API key content...")
        
        api_key_content = Base64.decode64(api_key_content_base64)
        UI.message("   Decoded length: #{api_key_content.length} characters")
        
        # Check if it looks like a valid P8 key
        if api_key_content.include?("BEGIN PRIVATE KEY") && api_key_content.include?("END PRIVATE KEY")
          UI.success("âœ… API key content appears to be valid P8 format")
        else
          UI.error("âŒ API key content doesn't appear to be valid P8 format")
          UI.message("   First 50 chars: #{api_key_content[0..49]}")
        end
        
        UI.message("âœ… Creating App Store Connect API configuration")
        
        # ğŸ”§ FIXED: Create both API object AND file for altool compatibility
        
        # 1. Create API object for Fastlane actions
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,
          duration: 1200,
          in_house: false
        }
        
        # 2. ğŸ”§ NEW: Create API key file for altool compatibility
        api_key_dir = File.expand_path("./private_keys")
        Dir.mkdir(api_key_dir) unless Dir.exist?(api_key_dir)
        
        api_key_file = "#{api_key_dir}/AuthKey_#{api_key_id}.p8"
        File.write(api_key_file, api_key_content)
        
        UI.message("âœ… Created API key file: #{api_key_file}")
        
        # 3. Set environment for altool
        ENV['API_PRIVATE_KEYS_DIR'] = api_key_dir
        
        UI.success("âœ… App Store Connect API key object and file created successfully")
        app_store_connect_api_key
        
      rescue => e
        UI.error("âŒ Failed to create API key object: #{e.message}")
        UI.error("   Error class: #{e.class}")
        UI.message("âš ï¸ Will use traditional auth")
        nil
      end
    else
      UI.error("âš ï¸ API key not available, using traditional auth")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_content_base64
      UI.message("Missing: #{missing_items.join(', ')}")
      nil
    end
  end
  
  # ğŸ”§ Helper method à¸ªà¸³à¸«à¸£à¸±à¸š setup certificates à¸à¸£à¹‰à¸­à¸¡ API key
  private_lane :setup_certificates_with_api_key do |options|
    readonly_mode = options[:readonly] || true
    cert_type = options[:type] || "appstore"
    
    UI.header("ğŸ” CERTIFICATES & PROVISIONING SETUP")
    UI.message("   Type: #{cert_type}")
    UI.message("   Readonly: #{readonly_mode}")
    
    # à¸ªà¸£à¹‰à¸²à¸‡ match options
    match_options = {
      type: cert_type,
      readonly: readonly_mode,
      verbose: true
    }
    
    # à¹€à¸à¸´à¹ˆà¸¡ API key à¸–à¹‰à¸²à¸¡à¸µ
    api_key_object = create_api_key_object
    if api_key_object
      match_options[:api_key] = api_key_object
      UI.success("âœ… Using App Store Connect API for Match authentication")
    else
      UI.message("âš ï¸ Using traditional auth for Match (requires FASTLANE_PASSWORD)")
    end
    
    # à¹€à¸£à¸µà¸¢à¸à¹ƒà¸Šà¹‰ match
    begin
      match(match_options)
      UI.success("âœ… Certificates setup completed!")
    rescue => e
      UI.error("âŒ Match failed: #{e.message}")
      raise e
    end
  end
  
  # ğŸ”§ FIXED: TestFlight upload with enhanced error handling
  private_lane :deploy_to_testflight_internal do
    UI.header("ğŸ”’ TESTFLIGHT INTERNAL UPLOAD")
    
    # ğŸ” PRE-UPLOAD CHECKS - Use Lane Context path
    ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
    
    unless ipa_path && File.exist?(ipa_path)
      # Fallback to common paths
      possible_paths = ["build/Runner.ipa", "../build/Runner.ipa"]
      ipa_path = possible_paths.find { |p| File.exist?(p) }
      
      unless ipa_path
        UI.user_error!("âŒ IPA file not found in expected locations")
      end
    end
    
    UI.message("ğŸ“¦ IPA file: #{ipa_path}")
    UI.message("ğŸ“¦ IPA size: #{(File.size(ipa_path) / 1024.0 / 1024.0).round(2)} MB")
    
    upload_options = {
      ipa: ipa_path,
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Internal testing build - #{Time.now.strftime('%Y-%m-%d %H:%M')}",
      skip_waiting_for_build_processing: true,
      skip_submission: true
    }
    
    # ğŸ”§ CRITICAL: Ensure API key file exists for altool
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("âœ… Using App Store Connect API for TestFlight Internal upload")
      
      # ğŸ” Verify API key file exists for altool
      api_key_file = "./private_keys/AuthKey_#{api_key_object[:key_id]}.p8"
      if File.exist?(api_key_file)
        UI.success("âœ… API key file exists for altool: #{api_key_file}")
      else
        UI.error("âŒ API key file missing for altool: #{api_key_file}")
      end
      
    else
      UI.message("âš ï¸ Using traditional auth for TestFlight Internal upload")
    end
    
    # ğŸ” ENHANCED UPLOAD WITH ERROR HANDLING
    begin
      UI.message("ğŸš€ Starting upload to TestFlight...")
      UI.message("â±ï¸ Upload started at: #{Time.now}")
      
      upload_to_testflight(upload_options)
      
      UI.success("âœ… Upload completed successfully!")
      UI.message("â±ï¸ Upload finished at: #{Time.now}")
      
    rescue => upload_error
      UI.header("âŒ TESTFLIGHT UPLOAD FAILED")
      UI.error("Error: #{upload_error.message}")
      UI.error("Class: #{upload_error.class}")
      
      # ğŸ” ENHANCED ERROR ANALYSIS
      error_message = upload_error.message.downcase
      
      if error_message.include?("authkey") || error_message.include?("failed to load")
        UI.message("ğŸ’¡ This is an API key file loading error")
        UI.message("ğŸ’¡ Suggested fixes:")
        UI.message("   â€¢ Check API key file exists in ./private_keys/")
        UI.message("   â€¢ Verify API key content is valid P8 format") 
        UI.message("   â€¢ Ensure API_PRIVATE_KEYS_DIR is set correctly")
        
        # Show current state
        UI.message("ğŸ” Current API key environment:")
        UI.message("   API_PRIVATE_KEYS_DIR: #{ENV['API_PRIVATE_KEYS_DIR']}")
        if Dir.exist?("./private_keys")
          UI.message("   Files in private_keys: #{Dir.glob('./private_keys/*').join(', ')}")
        else
          UI.message("   private_keys directory: Not found")
        end
      end
      
      if error_message.include?("altool")
        UI.message("ğŸ’¡ This is an altool-related error")
        if error_message.include?("object cannot be nil")
          UI.message("ğŸ’¡ Possible causes:")
          UI.message("   â€¢ API key doesn't have TestFlight permissions")
          UI.message("   â€¢ App not properly configured in App Store Connect")
          UI.message("   â€¢ API key file format issue")
        end
      end
      
      raise upload_error
    end
  end
  
  # Add other deployment methods...
  private_lane :deploy_to_testflight_beta do
    UI.header("âœˆï¸ TESTFLIGHT BETA UPLOAD")
    # Similar implementation with API key file handling...
  end
  
  private_lane :deploy_to_app_store do
    UI.header("ğŸª APP STORE UPLOAD") 
    # Similar implementation with API key file handling...
  end
  
  # Enhanced error handling with cleanup
  error do |lane, exception|
    UI.header("âŒ FASTLANE ERROR")
    UI.error("Lane: #{lane}")
    UI.error("Error: #{exception.message}")
    UI.error("Class: #{exception.class}")
    
    # Clean up API key files on error
    if Dir.exist?("./private_keys")
      UI.message("ğŸ§¹ Cleaning up API key files...")
      Dir.glob("./private_keys/AuthKey_*.p8").each do |file|
        File.delete(file)
        UI.message("   Deleted: #{file}")
      end
    end
    
    # Clean up build artifacts on error
    if File.exist?("build")
      UI.message("ğŸ§¹ Cleaning up build artifacts...")
      sh("rm -rf build")
    end
    
    if ENV['CI']
      UI.message("ğŸ“‹ Fastlane logs available in artifacts")
    end
  end
end