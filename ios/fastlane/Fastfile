# ios/fastlane/Fastfile - Enhanced with React Native workflow features
default_platform(:ios)

platform :ios do
  
  before_all do
    ENV["FASTLANE_SKIP_UPDATE_CHECK"] = "1"
    setup_ci if ENV['CI']
    ensure_bundle_exec
    auto_update_version if ENV['GITHUB_RUN_NUMBER']
  end

  # ‚ú® Auto version management ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Flutter
  private_lane :auto_update_version do
    begin
      # ‡∏î‡∏∂‡∏á version ‡∏à‡∏≤‡∏Å pubspec.yaml
      pubspec_path = File.expand_path('../../pubspec.yaml')
      if File.exist?(pubspec_path)
        pubspec_content = File.read(pubspec_path)
        version_match = pubspec_content.match(/^version:\s*(.+)$/m)
        if version_match
          version_full = version_match[1].strip
          # ‡πÅ‡∏¢‡∏Å version ‡πÅ‡∏•‡∏∞ build number (format: 1.2.3+4)
          if version_full.include?('+')
            version_parts = version_full.split('+')
            new_version = version_parts[0]
            build_number = version_parts[1]
          else
            new_version = version_full
            build_number = ENV['GITHUB_RUN_NUMBER'] || "1"
          end
        else
          UI.error("Version not found in pubspec.yaml, using default")
          new_version = "1.0.0"
          build_number = ENV['GITHUB_RUN_NUMBER'] || "1"
        end
      else
        UI.error("pubspec.yaml not found, using default version")
        new_version = "1.0.0"
        build_number = ENV['GITHUB_RUN_NUMBER'] || "1"
      end
      
      branch = ENV['GITHUB_REF_NAME'] || 'develop'
      
      # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó iOS version ‡πÉ‡∏ô Xcode project
      increment_version_number(
        version_number: new_version,
        xcodeproj: "Runner.xcodeproj"
      )
      
      increment_build_number(
        build_number: build_number,
        xcodeproj: "Runner.xcodeproj"
      )
      
      UI.success("‚úÖ Auto updated iOS version from pubspec.yaml:")
      UI.success("   CFBundleShortVersionString: #{new_version}")
      UI.success("   CFBundleVersion: #{build_number}")
      UI.success("   branch: #{branch}")
      
    rescue => e
      UI.error("‚ùå Failed to auto update version: #{e.message}")
      UI.error("Continuing with existing version...")
    end
  end

  # ‚ú® Manual version management
  lane :set_version do |options|
    version = options[:version] || prompt(text: "Enter version (e.g., 1.2.3):")
    build = options[:build] || prompt(text: "Enter build number (e.g., 123):")
    
    increment_version_number(
      version_number: version,
      xcodeproj: "Runner.xcodeproj"
    )
    
    increment_build_number(
      build_number: build,
      xcodeproj: "Runner.xcodeproj"
    )
    
    # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó pubspec.yaml ‡∏î‡πâ‡∏ß‡∏¢
    update_pubspec_version(version: version, build: build)
    
    UI.success("‚úÖ Manually set version:")
    UI.success("   iOS CFBundleShortVersionString: #{version}")
    UI.success("   iOS CFBundleVersion: #{build}")
    UI.success("   pubspec.yaml updated")
  end

  lane :bump_version do |options|
    type = options[:type] || "patch"
    
    # ‡∏≠‡πà‡∏≤‡∏ô version ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏à‡∏≤‡∏Å iOS project
    current_version = get_version_number(xcodeproj: "Runner.xcodeproj")
    current_build = get_build_number(xcodeproj: "Runner.xcodeproj").to_i
    
    # Parse semantic version
    version_parts = current_version.split('.').map(&:to_i)
    
    case type
    when "major"
      version_parts[0] += 1
      version_parts[1] = 0
      version_parts[2] = 0
    when "minor"
      version_parts[1] += 1
      version_parts[2] = 0
    when "patch"
      version_parts[2] += 1
    end
    
    new_version = version_parts.join('.')
    new_build = current_build + 1
    
    increment_version_number(
      version_number: new_version,
      xcodeproj: "Runner.xcodeproj"
    )
    
    increment_build_number(
      build_number: new_build.to_s,
      xcodeproj: "Runner.xcodeproj"
    )
    
    # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó pubspec.yaml ‡∏î‡πâ‡∏ß‡∏¢
    update_pubspec_version(version: new_version, build: new_build.to_s)
    
    UI.success("‚úÖ Bumped #{type} version:")
    UI.success("   #{current_version} -> #{new_version}")
    UI.success("   build: #{current_build} -> #{new_build}")
  end

  # üöÄ Main deployment lane
  desc "Deploy to App Store Connect"
  lane :deploy do |options|
    target = options[:target] || "testflight_internal"
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("üçé Building and deploying Flutter iOS")
    UI.message("üéØ Target: #{target}")
    UI.message("üìã Version: #{version} (#{build_number})")
    
    # Setup certificates and provisioning profiles with Match
    setup_certificates
    
    # Update version numbers
    increment_version_number(version_number: version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter iOS
    build_flutter_ios(version: version, build_number: build_number)
    
    # Build and archive with Xcode
    build_ios_app
    
    # Deploy based on target
    case target
    when "app_store"
      deploy_to_app_store
    when "testflight_beta"
      deploy_to_testflight_beta
    when "testflight_internal"
      deploy_to_testflight_internal
    else
      UI.user_error!("‚ùå Unknown target: #{target}")
    end
    
    UI.success("‚úÖ Successfully deployed to #{target}!")
  end

  # üîß Helper method ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á App Store Connect API key object
  private_lane :create_api_key_object do
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        require 'base64'
        api_key_content = Base64.decode64(api_key_content_base64)
        
        UI.message("‚úÖ Creating App Store Connect API configuration")
        UI.message("   Key ID: #{api_key_id}")
        UI.message("   Issuer ID: #{api_issuer_id}")
        UI.message("   Content length: #{api_key_content.length} characters")
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á App Store Connect API object
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,
          duration: 1200, # 20 minutes
          in_house: false
        }
        
        UI.success("‚úÖ App Store Connect API key object created")
        return app_store_connect_api_key
        
      rescue => e
        UI.error("‚ùå Failed to create API key object: #{e.message}")
        UI.error("   Error class: #{e.class}")
        UI.message("‚ö†Ô∏è Will use traditional auth")
        return nil
      end
    else
      UI.message("‚ö†Ô∏è API key not available, using traditional auth")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_content_base64
      UI.message("Missing: #{missing_items.join(', ')}")
      return nil
    end
  end

  # üîß Enhanced certificates setup
  private_lane :setup_certificates do
    UI.message("üîê Setting up certificates...")
    
    begin
      match(
        type: "appstore",
        readonly: false,
        git_url: ENV['MATCH_GIT_URL'],
        app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
      )
      
      UI.success("‚úÖ Certificates setup completed")
    rescue => e
      UI.error("‚ùå Failed to setup certificates: #{e.message}")
      
      # ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏° readonly mode
      UI.message("üîÑ Trying readonly mode...")
      match(
        type: "appstore",
        readonly: true,
        git_url: ENV['MATCH_GIT_URL'],
        app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
      )
      
      UI.success("‚úÖ Certificates setup completed (readonly)")
    end
  end

  # üîß Enhanced Flutter build
  private_lane :build_flutter_ios do |options|
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("üî® Building Flutter iOS...")
    
    # Verify Flutter installation
    sh("flutter --version")
    
    # Clean previous builds
    sh("cd .. && flutter clean")
    
    # Get dependencies
    sh("cd .. && flutter pub get")
    
    # Build Flutter iOS (without codesign - Fastlane will handle it)
    build_command = [
      "cd ..",
      "flutter build ios",
      "--release",
      "--no-codesign",
      "--build-name=#{version}",
      "--build-number=#{build_number}"
    ].join(" && ")
    
    begin
      sh(build_command)
      UI.success("‚úÖ Flutter iOS build completed")
    rescue => e
      UI.error("‚ùå Flutter build failed: #{e.message}")
      raise e
    end
  end

  # üîß Enhanced iOS app build
  private_lane :build_ios_app do
    UI.message("üî® Building iOS app with Xcode...")
    
    begin
      build_app(
        workspace: "Runner.xcworkspace",
        scheme: "Runner",
        configuration: "Release",
        export_method: "app-store",
        output_directory: "build",
        output_name: "Runner.ipa",
        clean: true,
        silent: true,
        export_options: {
          method: "app-store",
          provisioningProfiles: {
            CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier) => 
              "match AppStore #{CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)}"
          }
        }
      )
      
      # Verify build
      ipa_path = "build/Runner.ipa"
      if File.exist?(ipa_path)
        file_size = (File.size(ipa_path) / 1024.0 / 1024.0).round(2)
        UI.success("‚úÖ iOS app built successfully: #{file_size} MB")
      else
        UI.error("‚ùå IPA file not found at: #{ipa_path}")
        raise "Build failed - IPA not created"
      end
      
    rescue => e
      UI.error("‚ùå iOS app build failed: #{e.message}")
      raise e
    end
  end

  # üîß Deployment methods with enhanced API key support
  private_lane :deploy_to_app_store do
    UI.message("üè™ Uploading to App Store...")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false,
      automatic_release: false,
      force: true,
      precheck_include_in_app_purchases: false
    }
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ API key object ‡πÅ‡∏ó‡∏ô traditional auth
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for App Store upload")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for App Store upload")
    end
    
    upload_to_app_store(upload_options)
    UI.success("‚úÖ App Store upload completed!")
  end
  
  private_lane :deploy_to_testflight_beta do
    UI.message("‚úàÔ∏è Uploading to TestFlight (Beta)...")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      groups: ["Beta Testers"],
      distribute_external: true,
      notify_external_testers: true,
      changelog: "Beta release - please test and provide feedback",
      skip_waiting_for_build_processing: false
    }
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ API key object
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for TestFlight Beta upload")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for TestFlight Beta upload")
    end
    
    upload_to_testflight(upload_options)
    UI.success("‚úÖ TestFlight Beta upload completed!")
  end
  
  private_lane :deploy_to_testflight_internal do
    UI.message("üîí Uploading to TestFlight (Internal)...")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Internal testing build",
      skip_waiting_for_build_processing: true
    }
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ API key object
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for TestFlight Internal upload")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for TestFlight Internal upload")
    end
    
    upload_to_testflight(upload_options)
    UI.success("‚úÖ TestFlight Internal upload completed!")
  end

  # üîß Convenience lanes for specific branches
  desc "Deploy to App Store (main branch)"
  lane :deploy_production do
    deploy(target: "app_store")
  end
  
  desc "Deploy to TestFlight Beta (staging branch)"
  lane :deploy_staging do
    deploy(target: "testflight_beta")
  end
  
  desc "Deploy to TestFlight Internal (develop branch)"
  lane :deploy_development do
    deploy(target: "testflight_internal")
  end

  # üîß Build-only lane (no deployment)
  desc "Build only (no deploy)"
  lane :build_only do |options|
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("üî® Building Flutter iOS app...")
    UI.message("üìã Version: #{version} (#{build_number})")
    
    # Setup certificates
    setup_certificates
    
    # Update version
    increment_version_number(version_number: version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter
    build_flutter_ios(version: version, build_number: build_number)
    
    # Build iOS app
    build_ios_app
    
    UI.success("‚úÖ Flutter iOS build completed!")
  end
  
  desc "Setup certificates only"
  lane :setup_certificates_only do
    setup_certificates
    UI.success("‚úÖ Certificates setup completed!")
  end

  # üîß Submit for review lane with API key support
  desc "Submit for App Store review"
  lane :submit_for_review do
    UI.message("üìã Submitting for App Store review...")
    
    upload_options = {
      skip_binary_upload: true,
      submit_for_review: true,
      automatic_release: false,
      force: true,
      submission_information: submission_info
    }
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ API key object
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for review submission")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for review submission")
    end
    
    upload_to_app_store(upload_options)
    UI.success("‚úÖ App submitted for review!")
  end

  # üîß Helper method ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó pubspec.yaml
  private_lane :update_pubspec_version do |options|
    version = options[:version]
    build = options[:build]
    
    pubspec_path = File.expand_path('../../pubspec.yaml')
    if File.exist?(pubspec_path)
      content = File.read(pubspec_path)
      new_content = content.gsub(/^version:\s*.*$/m, "version: #{version}+#{build}")
      File.write(pubspec_path, new_content)
      UI.success("‚úÖ Updated pubspec.yaml version to #{version}+#{build}")
    else
      UI.error("‚ùå pubspec.yaml not found")
    end
  end

  # üîß Submission information for App Store review
  private_lane :submission_info do
    {
      add_id_info_limits_tracking: true,
      add_id_info_serves_ads: false,
      add_id_info_tracks_action: true,
      add_id_info_tracks_install: true,
      add_id_info_uses_idfa: true,
      content_rights_has_rights: true,
      content_rights_contains_third_party_content: true,
      export_compliance_platform: 'ios',
      export_compliance_compliance_required: false,
      export_compliance_encryption_updated: false,
      export_compliance_uses_encryption: false,
      export_compliance_is_exempt: false,
      export_compliance_contains_third_party_cryptography: false,
      export_compliance_contains_proprietary_cryptography: false,
      export_compliance_available_on_french_store: false
    }
  end

  # üîß Notification helper (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Slack ‡∏´‡∏£‡∏∑‡∏≠ Teams)
  private_lane :notify_deployment do |message|
    return unless ENV["SLACK_URL"]
    
    begin
      slack(
        message: message,
        channel: "#releases",
        webhook_url: ENV["SLACK_URL"],
        username: "Flutter iOS CI/CD",
        icon_emoji: ":flutter:"
      )
    rescue => e
      UI.error("Failed to send notification: #{e.message}")
    end
  end

  # Error handling
  error do |lane, exception|
    error_message = "‚ùå Flutter iOS deployment failed in lane '#{lane}': #{exception.message}"
    UI.error(error_message)
    
    # Clean up build artifacts on error
    if File.exist?("build")
      UI.message("üßπ Cleaning up build artifacts...")
      sh("rm -rf build")
    end
    
    # Clean Flutter build
    sh("cd .. && flutter clean") rescue nil
    
    if ENV['CI']
      UI.message("üìã Fastlane logs available in artifacts")
    end
    
    # notify_deployment(error_message) if defined?(notify_deployment)
    raise exception
  end
end