# ios/fastlane/Fastfile - Fixed using React Native pattern
default_platform(:ios)

platform :ios do
  before_all do
    ENV["FASTLANE_SKIP_UPDATE_CHECK"] = "1"
    setup_ci if ENV['CI']
  end

  desc "Deploy to App Store Connect"
  lane :deploy do |options|
    target = options[:target] || "testflight_internal"
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("üçé Building and deploying iOS")
    UI.message("üéØ Target: #{target}")
    UI.message("üìã Version: #{version} (#{build_number})")
    
    # Setup certificates and provisioning profiles with Match
    setup_certificates_with_api_key
    
    # Update version numbers
    increment_version_number(version_number: version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter iOS (without codesign - Fastlane will handle it)
    sh("cd .. && flutter build ios --release --no-codesign --build-name=#{version} --build-number=#{build_number}")
    
    # Build and archive with Xcode
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "build",
      output_name: "Runner.ipa",
      silent: false
    )
    
    # IPA VALIDATION
    validate_ipa_build
    
    # Deploy based on target
    case target
    when "app_store"
      deploy_to_app_store
    when "testflight_beta"
      deploy_to_testflight_beta
    when "testflight_internal"
      deploy_to_testflight_internal
    else
      UI.user_error!("‚ùå Unknown target: #{target}")
    end
    
    UI.success("‚úÖ Successfully deployed to #{target}!")
  end
  
  # üéØ FIXED: IPA Validation with correct path
  private_lane :validate_ipa_build do
    ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH] || "build/Runner.ipa"
    
    UI.header("üîç IPA BUILD VALIDATION")
    UI.message("üì¶ Checking IPA at: #{ipa_path}")
    
    unless File.exist?(ipa_path)
      UI.message("üîç Debug - Files in build directory:")
      if Dir.exist?("build")
        Dir.glob("build/*").each { |f| UI.message("   #{f}") }
      end
      
      alternative_paths = [
        "../build/Runner.ipa",
        "build/Runner.ipa", 
        "./build/Runner.ipa"
      ]
      
      found_path = alternative_paths.find { |path| File.exist?(path) }
      
      if found_path
        UI.message("‚úÖ Found IPA at alternative path: #{found_path}")
        ipa_path = found_path
      else
        UI.user_error!("‚ùå IPA file not found. Checked paths: #{[ipa_path] + alternative_paths}")
      end
    end
    
    # File size check
    ipa_size = (File.size(ipa_path) / 1024.0 / 1024.0).round(2)
    UI.message("üì¶ IPA Size: #{ipa_size} MB")
    
    # Basic validation
    if File.size(ipa_path) > 10 * 1024 * 1024  # > 10MB
      UI.success("‚úÖ IPA size looks reasonable (#{ipa_size} MB)")
    else
      UI.error("‚ö†Ô∏è IPA size seems small (#{ipa_size} MB) - might be incomplete")
    end
    
    # Quick zip test
    begin
      result = sh("unzip -t '#{ipa_path}' >/dev/null 2>&1 && echo 'VALID' || echo 'INVALID'", log: false).strip
      if result == "VALID"
        UI.success("‚úÖ IPA zip structure is valid")
      else
        UI.error("‚ùå IPA zip structure is corrupted")
      end
    rescue => e
      UI.message("‚ö†Ô∏è Could not validate IPA structure: #{e.message}")
    end
    
    UI.success("üîç IPA validation completed")
  end
  
  # üéØ FIXED: Using React Native pattern - API key object only
  private_lane :create_api_key_object do
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    UI.header("üîë APP STORE CONNECT API KEY SETUP")
    UI.message("üìã API Key Configuration:")
    UI.message("   Key ID: #{api_key_id ? "#{api_key_id[0..7]}..." : '‚ùå Missing'}")
    UI.message("   Issuer ID: #{api_issuer_id ? "#{api_issuer_id[0..7]}..." : '‚ùå Missing'}")
    UI.message("   Key Content: #{api_key_content_base64 ? "‚úÖ Available (#{api_key_content_base64.length} chars)" : '‚ùå Missing'}")
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        require 'base64'
        api_key_content = Base64.decode64(api_key_content_base64)
        
        UI.message("üîç Validating API key content...")
        UI.message("   Decoded length: #{api_key_content.length} characters")
        
        if api_key_content.include?("BEGIN PRIVATE KEY") && api_key_content.include?("END PRIVATE KEY")
          UI.success("‚úÖ API key content appears to be valid P8 format")
        else
          UI.error("‚ùå API key content doesn't appear to be valid P8 format")
        end
        
        # üéØ EXACT SAME OBJECT AS REACT NATIVE - NO FILE CREATION
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,  # Raw content - NO file path
          duration: 1200,        # 20 minutes
          in_house: false
        }
        
        UI.success("‚úÖ App Store Connect API key object created successfully")
        app_store_connect_api_key
        
      rescue => e
        UI.error("‚ùå Failed to create API key object: #{e.message}")
        nil
      end
    else
      UI.error("‚ö†Ô∏è API key not available")
      nil
    end
  end
  
  # Helper method for setup certificates with API key
  private_lane :setup_certificates_with_api_key do |options|
    readonly_mode = options[:readonly] || true
    cert_type = options[:type] || "appstore"
    
    UI.header("üîê CERTIFICATES & PROVISIONING SETUP")
    UI.message("   Type: #{cert_type}")
    UI.message("   Readonly: #{readonly_mode}")
    
    # Create match options
    match_options = {
      type: cert_type,
      readonly: readonly_mode,
      verbose: true
    }
    
    # Add API key if available
    api_key_object = create_api_key_object
    if api_key_object
      match_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for Match authentication")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for Match (requires FASTLANE_PASSWORD)")
    end
    
    # Run match
    begin
      match(match_options)
      UI.success("‚úÖ Certificates setup completed!")
    rescue => e
      UI.error("‚ùå Match failed: #{e.message}")
      raise e
    end
  end
  
  # üéØ FIXED: TestFlight Internal using React Native pattern
  private_lane :deploy_to_testflight_internal do
    UI.header("üîí TESTFLIGHT INTERNAL UPLOAD")
    
    # Get IPA path
    ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
    unless ipa_path && File.exist?(ipa_path)
      possible_paths = ["build/Runner.ipa", "../build/Runner.ipa"]
      ipa_path = possible_paths.find { |p| File.exist?(p) }
      unless ipa_path
        UI.user_error!("‚ùå IPA file not found")
      end
    end
    
    UI.message("üì¶ IPA file: #{ipa_path}")
    UI.message("üì¶ IPA size: #{(File.size(ipa_path) / 1024.0 / 1024.0).round(2)} MB")
    
    # üéØ USE EXACT SAME PATTERN AS REACT NATIVE
    upload_options = {
      ipa: ipa_path,
      skip_waiting_for_build_processing: true,
      groups: ["Internal Testers", "Developers"],  # Same as RN
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Automated build from #{ENV['GITHUB_REF_NAME'] || 'develop'} branch",  # Same as RN
      use_transporter: true,      # ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÉ‡∏ä‡πâ transporter
      transporter: "transporter"  # ‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠ executable
    }
    
    # üîß EXACT SAME API KEY SETUP AS REACT NATIVE VERSION
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        # Decode API key content (same as RN)
        require 'base64'
        api_key_content = Base64.decode64(api_key_content_base64)
        
        UI.message("‚úÖ Creating App Store Connect API configuration for TestFlight")
        UI.message("   Key ID: #{api_key_id}")
        UI.message("   Issuer ID: #{api_issuer_id}")
        UI.message("   Content length: #{api_key_content.length} characters")
        
        # üéØ EXACT SAME API OBJECT AS REACT NATIVE
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,    # Raw content, NOT file path
          duration: 1200,          # 20 minutes (same as RN)
          in_house: false
        }
        
        upload_options[:api_key] = app_store_connect_api_key
        UI.success("‚úÖ Using App Store Connect API for TestFlight upload")
        
      rescue => e
        UI.error("‚ùå Failed to setup API key: #{e.message}")
        UI.error("   Error class: #{e.class}")
        UI.message("‚ö†Ô∏è Falling back to traditional auth")
      end
    else
      UI.message("‚ö†Ô∏è API key not available, using traditional auth")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_content_base64
      UI.message("Missing: #{missing_items.join(', ')}")
    end
    
    # üöÄ UPLOAD (same method as RN)
    begin
      UI.message("üöÄ Starting upload to TestFlight...")
      upload_to_testflight(upload_options)
      UI.success("‚úÖ Upload completed successfully!")
      
    rescue => e
      UI.error("‚ùå Upload failed: #{e.message}")
      
      # Same error handling as RN
      error_message = "‚ùå iOS deployment failed: #{e.message}"
      UI.error(error_message)
      raise e
    end
  end
  
  # üéØ FIXED: TestFlight Beta using React Native pattern
  private_lane :deploy_to_testflight_beta do
    UI.header("‚úàÔ∏è TESTFLIGHT BETA UPLOAD")
    
    ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
    unless ipa_path && File.exist?(ipa_path)
      possible_paths = ["build/Runner.ipa", "../build/Runner.ipa"]
      ipa_path = possible_paths.find { |p| File.exist?(p) }
      unless ipa_path
        UI.user_error!("‚ùå IPA file not found")
      end
    end
    
    UI.message("üì¶ IPA file: #{ipa_path}")
    UI.message("üì¶ IPA size: #{(File.size(ipa_path) / 1024.0 / 1024.0).round(2)} MB")
    
    upload_options = {
      ipa: ipa_path,
      skip_waiting_for_build_processing: false,  # Wait for beta
      groups: ["Beta Testers", "QA Team"],
      distribute_external: true,
      notify_external_testers: true,
      changelog: "Beta build from #{ENV['GITHUB_REF_NAME'] || 'preprod'} branch",
      use_transporter: true,      # ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÉ‡∏ä‡πâ transporter
      transporter: "transporter"  # ‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠ executable
    }
    
    # Same API key setup as internal
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        require 'base64'
        api_key_content = Base64.decode64(api_key_content_base64)
        
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,
          duration: 1200,
          in_house: false
        }
        
        upload_options[:api_key] = app_store_connect_api_key
        UI.success("‚úÖ Using App Store Connect API for TestFlight Beta upload")
        
      rescue => e
        UI.error("‚ùå Failed to setup API key: #{e.message}")
        UI.message("‚ö†Ô∏è Falling back to traditional auth")
      end
    end
    
    begin
      UI.message("üöÄ Starting upload to TestFlight Beta...")
      upload_to_testflight(upload_options)
      UI.success("‚úÖ Beta upload completed successfully!")
      
    rescue => e
      UI.error("‚ùå Beta upload failed: #{e.message}")
      raise e
    end
  end
  
  # üéØ FIXED: App Store using React Native pattern
  private_lane :deploy_to_app_store do
    UI.header("üè™ APP STORE UPLOAD")
    
    ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
    unless ipa_path && File.exist?(ipa_path)
      possible_paths = ["build/Runner.ipa", "../build/Runner.ipa"]
      ipa_path = possible_paths.find { |p| File.exist?(p) }
      unless ipa_path
        UI.user_error!("‚ùå IPA file not found")
      end
    end
    
    UI.message("üì¶ IPA file: #{ipa_path}")
    UI.message("üì¶ IPA size: #{(File.size(ipa_path) / 1024.0 / 1024.0).round(2)} MB")
    
    upload_options = {
      ipa: ipa_path,
      force: true,
      submit_for_review: false,
      automatic_release: false,
      skip_metadata: true,
      skip_screenshots: true,
      precheck_include_in_app_purchases: false,
      use_transporter: true,      # ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÉ‡∏ä‡πâ transporter
      transporter: "transporter"  # ‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠ executable
    }
    
    # Same API key setup
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        require 'base64'
        api_key_content = Base64.decode64(api_key_content_base64)
        
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,
          duration: 1200,
          in_house: false
        }
        
        upload_options[:api_key] = app_store_connect_api_key
        UI.success("‚úÖ Using App Store Connect API for App Store upload")
        
      rescue => e
        UI.error("‚ùå Failed to setup API key: #{e.message}")
        UI.message("‚ö†Ô∏è Falling back to traditional auth")
      end
    end
    
    begin
      UI.message("üöÄ Starting upload to App Store...")
      upload_to_app_store(upload_options)
      UI.success("‚úÖ App Store upload completed successfully!")
      
    rescue => e
      UI.error("‚ùå App Store upload failed: #{e.message}")
      raise e
    end
  end
  
  # Helper lanes
  desc "Build only (no deploy)"
  lane :build_only do |options|
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    setup_certificates_with_api_key
    increment_version_number(version_number: version)
    increment_build_number(build_number: build_number)
    
    sh("cd .. && flutter build ios --release --no-codesign --build-name=#{version} --build-number=#{build_number}")
    
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "build",
      output_name: "Runner.ipa"
    )
    
    validate_ipa_build
    
    UI.success("‚úÖ IPA ready for manual upload!")
    UI.message("üì¶ Location: #{lane_context[SharedValues::IPA_OUTPUT_PATH]}")
  end
  
  desc "Setup certificates only"
  lane :setup_certificates do |options|
    setup_certificates_with_api_key(options)
  end
  
  # Enhanced error handling with cleanup
  error do |lane, exception|
    UI.header("‚ùå FASTLANE ERROR")
    UI.error("Lane: #{lane}")
    UI.error("Error: #{exception.message}")
    UI.error("Class: #{exception.class}")
    
    # Clean up build artifacts on error
    if File.exist?("build")
      UI.message("üßπ Cleaning up build artifacts...")
      sh("rm -rf build")
    end
    
    if ENV['CI']
      UI.message("üìã Fastlane logs available in artifacts")
    end
  end
end