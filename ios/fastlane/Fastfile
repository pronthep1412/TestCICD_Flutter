# ios/fastlane/Fastfile - Updated with API key object support for ALL actions
default_platform(:ios)

platform :ios do
  before_all do
    ENV["FASTLANE_SKIP_UPDATE_CHECK"] = "1"
    setup_ci if ENV['CI']
  end

  desc "Deploy to App Store Connect"
  lane :deploy do |options|
    target = options[:target] || "testflight_internal"
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("üçé Building and deploying iOS")
    UI.message("üéØ Target: #{target}")
    UI.message("üìã Version: #{version} (#{build_number})")
    
    # üîß Setup certificates and provisioning profiles with Match + API Key
    setup_certificates_with_api_key
    
    # Update version numbers
    increment_version_number(version_number: version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter iOS (without codesign - Fastlane will handle it)
    sh("cd .. && flutter build ios --release --no-codesign --build-name=#{version} --build-number=#{build_number}")
    
    # Build and archive with Xcode
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "build",
      output_name: "Runner.ipa",
      silent: true
    )
    
    # Deploy based on target
    case target
    when "app_store"
      deploy_to_app_store
    when "testflight_beta"
      deploy_to_testflight_beta
    when "testflight_internal"
      deploy_to_testflight_internal
    else
      UI.user_error!("‚ùå Unknown target: #{target}")
    end
    
    UI.success("‚úÖ Successfully deployed to #{target}!")
  end
  
  # üîß Helper method ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á App Store Connect API key object
  private_lane :create_api_key_object do
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        require 'base64'
        api_key_content = Base64.decode64(api_key_content_base64)
        
        UI.message("‚úÖ Creating App Store Connect API configuration")
        UI.message("   Key ID: #{api_key_id}")
        UI.message("   Issuer ID: #{api_issuer_id}")
        UI.message("   Content length: #{api_key_content.length} characters")
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á App Store Connect API object
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,
          duration: 1200, # 20 minutes
          in_house: false
        }
        
        UI.success("‚úÖ App Store Connect API key object created")
        app_store_connect_api_key
        
      rescue => e
        UI.error("‚ùå Failed to create API key object: #{e.message}")
        UI.error("   Error class: #{e.class}")
        UI.message("‚ö†Ô∏è Will use traditional auth")
        nil
      end
    else
      UI.message("‚ö†Ô∏è API key not available, using traditional auth")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_content_base64
      UI.message("Missing: #{missing_items.join(', ')}")
      nil
    end
  end
  
  # üîß NEW: Helper method ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö setup certificates ‡∏û‡∏£‡πâ‡∏≠‡∏° API key
  private_lane :setup_certificates_with_api_key do |options|
    readonly_mode = options[:readonly] || false  # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô true ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á templateName bug
    cert_type = options[:type] || "appstore"
    
    UI.message("üîê Setting up certificates...")
    UI.message("   Type: #{cert_type}")
    UI.message("   Readonly: #{readonly_mode}")
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á match options
    match_options = {
      type: cert_type,
      readonly: readonly_mode
    }
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏° API key ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    api_key_object = create_api_key_object
    if api_key_object
      match_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for Match authentication")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for Match (requires FASTLANE_PASSWORD)")
    end
    
    # ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ match
    match(match_options)
    UI.success("‚úÖ Certificates setup completed!")
  end
  
  # üîß Private lanes for different deployment targets with API key support
  private_lane :deploy_to_app_store do
    UI.message("üè™ Uploading to App Store...")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false,
      automatic_release: false,
      force: true,
      precheck_include_in_app_purchases: false
    }
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ API key object ‡πÅ‡∏ó‡∏ô traditional auth
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for App Store upload")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for App Store upload")
    end
    
    upload_to_app_store(upload_options)
  end
  
  private_lane :deploy_to_testflight_beta do
    UI.message("‚úàÔ∏è Uploading to TestFlight (Beta)...")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      groups: ["Beta Testers"],
      distribute_external: true,
      notify_external_testers: true,
      changelog: "Beta release - please test and provide feedback",
      skip_waiting_for_build_processing: false
    }
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ API key object
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for TestFlight Beta upload")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for TestFlight Beta upload")
    end
    
    upload_to_testflight(upload_options)
  end
  
  private_lane :deploy_to_testflight_internal do
    UI.message("üîí Uploading to TestFlight (Internal)...")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Internal testing build",
      skip_waiting_for_build_processing: true
    }
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ API key object
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for TestFlight Internal upload")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for TestFlight Internal upload")
    end
    
    upload_to_testflight(upload_options)
  end
  
  # Helper lanes for specific branches
  desc "Deploy to App Store (main branch)"
  lane :deploy_production do
    deploy(target: "app_store")
  end
  
  desc "Deploy to TestFlight Beta (staging branch)"
  lane :deploy_staging do
    deploy(target: "testflight_beta")
  end
  
  desc "Deploy to TestFlight Internal (develop branch)"
  lane :deploy_development do
    deploy(target: "testflight_internal")
  end
  
  # Debug/testing lanes
  desc "Build only (no deploy)"
  lane :build_only do |options|
    version = options[:version] || "1.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("üî® Building iOS app...")
    UI.message("üìã Version: #{version} (#{build_number})")
    
    # üîß Setup certificates ‡∏û‡∏£‡πâ‡∏≠‡∏° API key (‡πÉ‡∏ä‡πâ readonly ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏°‡∏µ cert ‡πÅ‡∏•‡πâ‡∏ß)
    setup_certificates_with_api_key(readonly: false)
    
    # Update version
    increment_version_number(version_number: version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter
    sh("cd .. && flutter build ios --release --no-codesign --build-name=#{version} --build-number=#{build_number}")
    
    # Build with Xcode
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "build",
      output_name: "Runner.ipa"
    )
    
    UI.success("‚úÖ iOS build completed!")
  end
  
  desc "Setup certificates only"
  lane :setup_certificates do |options|
    readonly_mode = options[:readonly] || false  # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô true
    cert_type = options[:type] || "appstore"
    
    # üîß ‡πÉ‡∏ä‡πâ helper method ‡πÉ‡∏´‡∏°‡πà
    setup_certificates_with_api_key(readonly: readonly_mode, type: cert_type)
  end
  
  # üîß Submit for review lane with API key support
  desc "Submit for App Store review"
  lane :submit_for_review do
    UI.message("üìã Submitting for App Store review...")
    
    upload_options = {
      skip_binary_upload: true,
      submit_for_review: true,
      automatic_release: false,
      force: true,
      submission_information: submission_info
    }
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ API key object
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("‚úÖ Using App Store Connect API for review submission")
    else
      UI.message("‚ö†Ô∏è Using traditional auth for review submission")
    end
    
    upload_to_app_store(upload_options)
    UI.success("‚úÖ App submitted for review!")
  end
  
  # üîß Submission information for App Store review
  private_lane :submission_info do
    {
      add_id_info_limits_tracking: true,
      add_id_info_serves_ads: false,
      add_id_info_tracks_action: true,
      add_id_info_tracks_install: true,
      add_id_info_uses_idfa: true,
      content_rights_has_rights: true,
      content_rights_contains_third_party_content: true,
      export_compliance_platform: 'ios',
      export_compliance_compliance_required: false,
      export_compliance_encryption_updated: false,
      export_compliance_uses_encryption: false,
      export_compliance_is_exempt: false,
      export_compliance_contains_third_party_cryptography: false,
      export_compliance_contains_proprietary_cryptography: false,
      export_compliance_available_on_french_store: false
    }
  end
  
  # Error handling
  error do |lane, exception|
    UI.error("‚ùå Error in #{lane}: #{exception.message}")
    
    # Clean up build artifacts on error
    if File.exist?("build")
      UI.message("üßπ Cleaning up build artifacts...")
      sh("rm -rf build")
    end
    
    if ENV['CI']
      UI.message("üìã Fastlane logs available in artifacts")
    end
  end
end