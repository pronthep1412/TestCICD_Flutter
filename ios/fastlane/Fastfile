# ios/fastlane/Fastfile - à¸‰à¸šà¸±à¸šà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œà¸«à¸¥à¸±à¸‡à¹à¸à¹‰à¹„à¸‚
default_platform(:ios)

platform :ios do
  before_all do
    ENV["FASTLANE_SKIP_UPDATE_CHECK"] = "1"
    setup_ci if ENV['CI']
  end

  desc "Deploy to App Store Connect"
  lane :deploy do |options|
    target = options[:target] || "testflight_internal"
    raw_version = options[:version] || "67000.0.0"
    build_number = options[:build_number] || "1"
    original_version = options[:original_version] || raw_version
    
    # âœ… Clean à¹à¸¥à¸° validate version
    clean_version = validate_and_clean_version(version: raw_version)
    
    UI.message("ğŸ Building and deploying iOS")
    UI.message("ğŸ¯ Target: #{target}")
    UI.message("ğŸ“‹ Raw Version: #{raw_version}")
    UI.message("ğŸ“‹ Clean Version: #{clean_version} (#{build_number})")
    UI.message("ğŸ“‹ Original Version: #{original_version}") if original_version != clean_version
    
    # ğŸ”§ Setup certificates and provisioning profiles
    setup_certificates_with_api_key
    
    # Update version numbers with clean version
    increment_version_number(version_number: clean_version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter iOS
    sh("cd .. && flutter build ios --release --no-codesign --build-name=#{clean_version} --build-number=#{build_number}")
    
    # Build and archive with Xcode
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "build",
      output_name: "Runner.ipa",
      silent: true
    )
    
    # Deploy based on target with retry mechanism
    case target
    when "app_store"
      deploy_to_app_store_with_retry(version: clean_version, original_version: original_version)
    when "testflight_beta"
      deploy_to_testflight_beta_with_retry(version: clean_version, original_version: original_version)
    when "testflight_internal"
      deploy_to_testflight_internal_with_retry(version: clean_version, original_version: original_version)
    else
      UI.user_error!("âŒ Unknown target: #{target}")
    end
    
    UI.success("âœ… Successfully deployed to #{target}!")
    UI.success("ğŸ“‹ Version deployed: #{clean_version} (build #{build_number})")
  end
  
  # ğŸ”§ Enhanced: Validate à¹à¸¥à¸° clean version format for App Store
  private_lane :validate_and_clean_version do |options|
    version = options[:version] || "67000.0.0"
    UI.message("ğŸ” Validating and cleaning version: #{version}")
    
    # Remove any whitespace
    clean_version = version.to_s.strip
    original_input = clean_version
    
    # Pattern matching à¹à¸¥à¸° cleaning
    case clean_version
    when /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/
      # 4-part version: X.Y.Z.W -> X.Y.Z
      major, minor, patch, build_part = $1, $2, $3, $4
      clean_version = "#{major}.#{minor}.#{patch}"
      UI.message("âš ï¸ 4-part version detected: #{original_input} â†’ #{clean_version}")
      UI.message("ğŸ’¡ Build part (#{build_part}) ignored for App Store compliance")
      
    when /^(\d+\.\d+\.\d+)-(alpha|beta|rc)\.?(\d+)?$/
      # Pre-release version: X.Y.Z-pre.N -> X.Y.Z
      base_version, prerelease, number = $1, $2, $3
      clean_version = base_version
      UI.message("âš ï¸ Pre-release version detected: #{original_input} â†’ #{clean_version}")
      UI.message("ğŸ’¡ Pre-release identifier (#{prerelease}) removed for App Store compliance")
      
    when /^(\d+)\.(\d+)$/
      # 2-part version: X.Y -> X.Y.0
      major, minor = $1, $2
      clean_version = "#{major}.#{minor}.0"
      UI.message("âš ï¸ 2-part version detected: #{original_input} â†’ #{clean_version}")
      
    when /^(\d+)$/
      # 1-part version: X -> X.0.0
      major = $1
      clean_version = "#{major}.0.0"
      UI.message("âš ï¸ 1-part version detected: #{original_input} â†’ #{clean_version}")
      
    when /^\d+\.\d+\.\d+$/
      # Already valid 3-part version
      UI.success("âœ… Version format is already valid: #{clean_version}")
      
    else
      # Invalid format - use smart fallback
      UI.error("âŒ Invalid version format: #{version}")
      UI.error("ğŸ’¡ Supported formats: X.Y.Z, X.Y.Z.W, X.Y.Z-alpha.N")
      UI.error("ğŸ“ Using fallback version: 67000.0.0")
      clean_version = "67000.0.0"
    end
    
    # Final validation
    unless clean_version.match?(/^\d+\.\d+\.\d+$/)
      UI.error("âŒ Final validation failed for: #{clean_version}")
      clean_version = "67000.0.0"
    end
    
    # Additional numeric validation à¹à¸¥à¸° App Store compliance
    parts = clean_version.split('.')
    parts.each_with_index do |part, index|
      unless part.match?(/^\d+$/) && part.to_i >= 0
        UI.error("âŒ Invalid version part at position #{index}: #{part}")
        clean_version = "67000.0.0"
        break
      end
    end
    
    # Check against minimum version (à¸¡à¸²à¸à¸à¸§à¹ˆà¸² 66666.0.0)
    min_version = "66666.0.0"
    if version_compare(version1: clean_version, version2: min_version) <= 0
      UI.warning("âš ï¸ Version #{clean_version} is not greater than minimum #{min_version}")
      # Auto increment
      min_parts = min_version.split('.')
      new_patch = min_parts[2].to_i + 1
      clean_version = "#{min_parts[0]}.#{min_parts[1]}.#{new_patch}"
      UI.message("ğŸ”„ Auto-incremented to: #{clean_version}")
    end
    
    UI.success("âœ… Final clean version: #{clean_version}")
    clean_version
  end
  
  # ğŸ”§ Helper: Compare versions
  private_lane :version_compare do |options|
    version1 = options[:version1]
    version2 = options[:version2]
    
    return 0 if version1 == version2
    
    v1_parts = version1.split('.').map(&:to_i)
    v2_parts = version2.split('.').map(&:to_i)
    
    max_length = [v1_parts.length, v2_parts.length].max
    
    max_length.times do |i|
      v1 = v1_parts[i] || 0
      v2 = v2_parts[i] || 0
      
      return 1 if v1 > v2
      return -1 if v1 < v2
    end
    
    0
  end
  
  # ğŸ”§ Helper method à¸ªà¸³à¸«à¸£à¸±à¸šà¸ªà¸£à¹‰à¸²à¸‡ App Store Connect API key object
  private_lane :create_api_key_object do
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content_base64 = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
    
    if api_key_id && api_issuer_id && api_key_content_base64
      begin
        require 'base64'
        api_key_content = Base64.decode64(api_key_content_base64)
        
        UI.message("âœ… Creating App Store Connect API configuration")
        UI.message("   Key ID: #{api_key_id}")
        UI.message("   Issuer ID: #{api_issuer_id}")
        UI.message("   Content length: #{api_key_content.length} characters")
        
        # à¸ªà¸£à¹‰à¸²à¸‡ App Store Connect API object
        app_store_connect_api_key = {
          key_id: api_key_id,
          issuer_id: api_issuer_id,
          key: api_key_content,
          duration: 1200, # 20 minutes
          in_house: false
        }
        
        UI.success("âœ… App Store Connect API key object created")
        app_store_connect_api_key
        
      rescue => e
        UI.error("âŒ Failed to create API key object: #{e.message}")
        UI.error("   Error class: #{e.class}")
        UI.message("âš ï¸ Will use traditional auth")
        nil
      end
    else
      UI.message("âš ï¸ API key not available, using traditional auth")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_content_base64
      UI.message("Missing: #{missing_items.join(', ')}")
      nil
    end
  end
  
  # ğŸ”§ Helper method à¸ªà¸³à¸«à¸£à¸±à¸š setup certificates à¸à¸£à¹‰à¸­à¸¡ API key
  private_lane :setup_certificates_with_api_key do |options|
    readonly_mode = options[:readonly] || true
    cert_type = options[:type] || "appstore"
    
    UI.message("ğŸ” Setting up certificates...")
    UI.message("   Type: #{cert_type}")
    UI.message("   Readonly: #{readonly_mode}")
    
    # à¸ªà¸£à¹‰à¸²à¸‡ match options
    match_options = {
      type: cert_type,
      readonly: readonly_mode
    }
    
    # à¹€à¸à¸´à¹ˆà¸¡ API key à¸–à¹‰à¸²à¸¡à¸µ
    api_key_object = create_api_key_object
    if api_key_object
      match_options[:api_key] = api_key_object
      UI.success("âœ… Using App Store Connect API for Match authentication")
    else
      UI.message("âš ï¸ Using traditional auth for Match (requires FASTLANE_PASSWORD)")
    end
    
    # à¹€à¸£à¸µà¸¢à¸à¹ƒà¸Šà¹‰ match
    match(match_options)
    UI.success("âœ… Certificates setup completed!")
  end
  
  # ğŸ”§ Enhanced deployment methods with retry mechanism
  private_lane :deploy_to_app_store_with_retry do |options|
    version = options[:version]
    original_version = options[:original_version]
    
    UI.message("ğŸª Uploading to App Store...")
    
    changelog_text = create_changelog(version: version, original_version: original_version, prefix: "Release")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false,
      automatic_release: false,
      force: true,
      precheck_include_in_app_purchases: false
    }
    
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("âœ… Using App Store Connect API for App Store upload")
    else
      UI.message("âš ï¸ Using traditional auth for App Store upload")
    end
    
    upload_with_retry(target: "app_store", upload_options: upload_options)
  end
  
  private_lane :deploy_to_testflight_beta_with_retry do |options|
    version = options[:version]
    original_version = options[:original_version]
    
    UI.message("âœˆï¸ Uploading to TestFlight (Beta)...")
    
    changelog_text = create_changelog(version: version, original_version: original_version, prefix: "Beta release")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      groups: ["Beta Testers"],
      distribute_external: true,
      notify_external_testers: true,
      changelog: changelog_text,
      skip_waiting_for_build_processing: false
    }
    
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("âœ… Using App Store Connect API for TestFlight Beta upload")
    else
      UI.message("âš ï¸ Using traditional auth for TestFlight Beta upload")
    end
    
    upload_with_retry(target: "testflight", upload_options: upload_options)
  end
  
  private_lane :deploy_to_testflight_internal_with_retry do |options|
    version = options[:version]
    original_version = options[:original_version]
    
    UI.message("ğŸ”’ Uploading to TestFlight (Internal)...")
    
    changelog_text = create_changelog(version: version, original_version: original_version, prefix: "Internal testing build")
    
    upload_options = {
      ipa: "build/Runner.ipa",
      distribute_external: false,
      notify_external_testers: false,
      changelog: changelog_text,
      skip_waiting_for_build_processing: true
    }
    
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("âœ… Using App Store Connect API for TestFlight Internal upload")
    else
      UI.message("âš ï¸ Using traditional auth for TestFlight Internal upload")
    end
    
    upload_with_retry(target: "testflight", upload_options: upload_options)
  end
  
  # ğŸ”§ Helper: Create appropriate changelog
  private_lane :create_changelog do |options|
    version = options[:version]
    original_version = options[:original_version]
    prefix = options[:prefix]
    
    if original_version != version
      "#{prefix} #{original_version} (App Store version: #{version})"
    else
      "#{prefix} #{version}"
    end
  end
  
  # ğŸ”§ Enhanced upload with retry mechanism
  private_lane :upload_with_retry do |options|
    target = options[:target]
    upload_options = options[:upload_options]
    
    max_retries = 3
    retry_delay = 30
    
    (1..max_retries).each do |attempt|
      begin
        UI.message("ğŸš€ Upload attempt #{attempt}/#{max_retries}")
        
        case target
        when "app_store"
          upload_to_app_store(upload_options)
        when "testflight"
          upload_to_testflight(upload_options)
        end
        
        UI.success("âœ… Upload successful on attempt #{attempt}")
        return
        
      rescue => e
        UI.error("âŒ Upload attempt #{attempt} failed: #{e.message}")
        
        # Check for specific errors
        if e.message.include?("object cannot be nil") || e.message.include?("-1010")
          UI.error("ğŸ” Detected altool nil object error")
          UI.error("ğŸ’¡ This usually indicates a version format issue")
          UI.error("ğŸ’¡ Current version format should be valid X.Y.Z")
          
        elsif e.message.include?("CFBundleShortVersionString")
          UI.error("ğŸ” Version format error in Info.plist")
          UI.error("ğŸ’¡ App Store requires version format: X.Y.Z")
          
        elsif e.message.include?("version that is already being used")
          UI.error("ğŸ” Version conflict detected")
          UI.error("ğŸ’¡ This version may already exist in App Store Connect")
          UI.error("ğŸ’¡ Try incrementing the version number")
          
        end
        
        if attempt < max_retries
          UI.message("â³ Waiting #{retry_delay} seconds before retry...")
          sleep(retry_delay)
          retry_delay += 15  # Increase delay for next retry
        else
          UI.user_error!("âŒ All upload attempts failed. Last error: #{e.message}")
        end
      end
    end
  end
  
  # Helper lanes for specific branches
  desc "Deploy to App Store (main branch)"
  lane :deploy_production do
    deploy(target: "app_store")
  end
  
  desc "Deploy to TestFlight Beta (staging branch)"
  lane :deploy_staging do
    deploy(target: "testflight_beta")
  end
  
  desc "Deploy to TestFlight Internal (develop branch)"
  lane :deploy_development do
    deploy(target: "testflight_internal")
  end
  
  # Debug/testing lanes
  desc "Build only (no deploy)"
  lane :build_only do |options|
    version = options[:version] || "67000.0.0"
    build_number = options[:build_number] || "1"
    
    UI.message("ğŸ”¨ Building iOS app...")
    UI.message("ğŸ“‹ Version: #{version} (#{build_number})")
    
    # âœ… Clean à¹à¸¥à¸° validate version
    clean_version = validate_and_clean_version(version: version)
    
    # ğŸ”§ Setup certificates à¸à¸£à¹‰à¸­à¸¡ API key
    setup_certificates_with_api_key(readonly: true)
    
    # Update version
    increment_version_number(version_number: clean_version)
    increment_build_number(build_number: build_number)
    
    # Build Flutter
    sh("cd .. && flutter build ios --release --no-codesign --build-name=#{clean_version} --build-number=#{build_number}")
    
    # Build with Xcode
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "build",
      output_name: "Runner.ipa"
    )
    
    UI.success("âœ… iOS build completed!")
  end
  
  desc "Setup certificates only"
  lane :setup_certificates do |options|
    readonly_mode = options[:readonly] || true
    cert_type = options[:type] || "appstore"
    
    # ğŸ”§ à¹ƒà¸Šà¹‰ helper method à¹ƒà¸«à¸¡à¹ˆ
    setup_certificates_with_api_key(readonly: readonly_mode, type: cert_type)
  end
  
  # ğŸ”§ Test version cleaning utility
  desc "Test version format cleaning"
  lane :test_version_formats do
    test_versions = [
      "1.0.0.84",           # 4-part version
      "1.0.0-alpha.84",     # Pre-release
      "67000.0.0",          # Valid 3-part (new baseline)
      "2.1",                # 2-part
      "3",                  # 1-part
      "1.0.0-beta.5",       # Beta version
      "invalid.version",    # Invalid
      "1.2.3.4.5",         # Too many parts
      "66666.0.0",          # Equal to minimum (should increment)
      "66665.0.0",          # Less than minimum (should increment)
    ]
    
    UI.message("ğŸ§ª Testing version format cleaning...")
    test_versions.each do |version|
      UI.message("Input: #{version}")
      clean = validate_and_clean_version(version: version)
      UI.message("Output: #{clean}")
      UI.message("---")
    end
  end
  
  # ğŸ”§ Submit for review lane with API key support
  desc "Submit for App Store review"
  lane :submit_for_review do
    UI.message("ğŸ“‹ Submitting for App Store review...")
    
    upload_options = {
      skip_binary_upload: true,
      submit_for_review: true,
      automatic_release: false,
      force: true,
      submission_information: submission_info
    }
    
    # âœ… à¹ƒà¸Šà¹‰ API key object
    api_key_object = create_api_key_object
    if api_key_object
      upload_options[:api_key] = api_key_object
      UI.success("âœ… Using App Store Connect API for review submission")
    else
      UI.message("âš ï¸ Using traditional auth for review submission")
    end
    
    upload_to_app_store(upload_options)
    UI.success("âœ… App submitted for review!")
  end
  
  # ğŸ”§ Submission information for App Store review
  private_lane :submission_info do
    {
      add_id_info_limits_tracking: true,
      add_id_info_serves_ads: false,
      add_id_info_tracks_action: true,
      add_id_info_tracks_install: true,
      add_id_info_uses_idfa: true,
      content_rights_has_rights: true,
      content_rights_contains_third_party_content: true,
      export_compliance_platform: 'ios',
      export_compliance_compliance_required: false,
      export_compliance_encryption_updated: false,
      export_compliance_uses_encryption: false,
      export_compliance_is_exempt: false,
      export_compliance_contains_third_party_cryptography: false,
      export_compliance_contains_proprietary_cryptography: false,
      export_compliance_available_on_french_store: false
    }
  end
  
  # ğŸ”§ Enhanced error handling
  error do |lane, exception|
    UI.error("âŒ Error in #{lane}: #{exception.message}")
    
    # Enhanced error diagnostics
    if exception.message.include?("CFBundleShortVersionString")
      UI.error("ğŸ” Version format error detected!")
      UI.error("ğŸ’¡ App Store requires version format: X.Y.Z (e.g., 67000.0.0)")
      UI.error("ğŸ’¡ Remove any alpha/beta/rc suffixes from version string")
      UI.error("ğŸ’¡ Ensure version is greater than 66666.0.0")
      
    elsif exception.message.include?("object cannot be nil") || exception.message.include?("-1010")
      UI.error("ğŸ” altool error detected!")
      UI.error("ğŸ’¡ This usually indicates a version format issue")
      UI.error("ğŸ’¡ Check Info.plist CFBundleShortVersionString value")
      UI.error("ğŸ’¡ Ensure version follows X.Y.Z format")
      
    elsif exception.message.include?("version that is already being used")
      UI.error("ğŸ” Version conflict detected!")
      UI.error("ğŸ’¡ This version already exists in App Store Connect")
      UI.error("ğŸ’¡ Increment version number or build number")
      
    elsif exception.message.include?("Invalid binary")
      UI.error("ğŸ” Binary validation error!")
      UI.error("ğŸ’¡ Check for missing architectures or invalid signatures")
      
    end
    
    # Clean up build artifacts on error
    if File.exist?("build")
      UI.message("ğŸ§¹ Cleaning up build artifacts...")
      sh("rm -rf build")
    end
    
    if ENV['CI']
      UI.message("ğŸ“‹ Fastlane logs available in artifacts")
      UI.message("ğŸ’¡ Check GitHub Actions artifacts for detailed logs")
    end
    
    # Provide helpful suggestions
    UI.message("")
    UI.message("ğŸ’¡ Troubleshooting suggestions:")
    UI.message("   1. Verify version format is X.Y.Z")
    UI.message("   2. Ensure version > 66666.0.0")
    UI.message("   3. Check App Store Connect for conflicting versions")
    UI.message("   4. Verify certificates and provisioning profiles")
    UI.message("   5. Check API key configuration")
  end
end