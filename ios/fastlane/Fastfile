# ios/fastlane/Fastfile - Static iOS Fastlane Configuration
default_platform(:ios)

platform :ios do
  
  before_all do
    setup_ci if ENV['CI']
    ensure_bundle_exec
  end

  desc "Deploy to TestFlight"
  lane :deploy do |options|
    UI.message("ğŸš€ Deploying Flutter iOS to TestFlight...")
    
    # Setup API key file first
    setup_api_key_file
    
    # Setup certificates
    setup_certificates
    
    # Build app
    build_flutter_app
    
    # Upload to TestFlight
    upload_to_testflight_with_retry(
      groups: ["Internal Testers"],
      skip_waiting: true
    )
    
    # Cleanup
    cleanup_api_key_file
    
    UI.success("ğŸ‰ Successfully deployed to TestFlight!")
  end

  desc "Build only"
  lane :build do
    UI.message("ğŸ”¨ Building Flutter iOS app...")
    
    # Setup API key file first
    setup_api_key_file
    
    # Setup certificates
    setup_certificates
    
    # Build app
    build_flutter_app
    
    # Cleanup
    cleanup_api_key_file
    
    UI.success("âœ… Flutter iOS build completed!")
  end

  # ğŸ”‘ Setup API key file à¹ƒà¸«à¹‰ Fastlane à¹ƒà¸Šà¹‰à¸‡à¸²à¸™
  private_lane :setup_api_key_file do
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content = ENV['APP_STORE_CONNECT_API_KEY']
    
    if api_key_id && api_issuer_id && api_key_content
      UI.message("âœ… Setting up API key file")
      UI.message("   Key ID: #{api_key_id}")
      UI.message("   Issuer ID: #{api_issuer_id}")
      UI.message("   Content length: #{api_key_content.length} characters")
      
      # à¸ªà¸£à¹‰à¸²à¸‡ directory à¸ªà¸³à¸«à¸£à¸±à¸š API key
      api_key_dir = File.expand_path("~/.appstoreconnect/private_keys")
      FileUtils.mkdir_p(api_key_dir) unless Dir.exist?(api_key_dir)
      
      # à¹€à¸‚à¸µà¸¢à¸™ API key à¸¥à¸‡à¹„à¸Ÿà¸¥à¹Œ
      api_key_file = File.join(api_key_dir, "AuthKey_#{api_key_id}.p8")
      File.write(api_key_file, api_key_content)
      
      # Set permissions
      File.chmod(0600, api_key_file)
      
      UI.success("âœ… API key file created at: #{api_key_file}")
      
      # à¹€à¸à¹‡à¸šà¹„à¸§à¹‰à¹ƒà¸™ lane context à¹€à¸à¸·à¹ˆà¸­ cleanup à¸ à¸²à¸¢à¸«à¸¥à¸±à¸‡
      Actions.lane_context[:API_KEY_FILE_PATH] = api_key_file
      
    else
      UI.message("âš ï¸ API key environment variables not available")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_content
      UI.message("Missing: #{missing_items.join(', ')}")
    end
  end

  # ğŸ—‘ï¸ Cleanup API key file
  private_lane :cleanup_api_key_file do
    api_key_file = Actions.lane_context[:API_KEY_FILE_PATH]
    if api_key_file && File.exist?(api_key_file)
      File.delete(api_key_file)
      UI.message("ğŸ—‘ï¸ Cleaned up API key file")
    end
  end

  # ğŸ” Setup certificates (simplified)
  private_lane :setup_certificates do
    UI.message("ğŸ” Setting up certificates...")
    
    match(
      type: "appstore",
      readonly: false
    )
    
    UI.success("âœ… Certificates setup completed")
  end

  # ğŸ”¨ Build Flutter app
  private_lane :build_flutter_app do
    # Build Flutter app first
    sh("cd ../.. && flutter build ios --release --no-codesign")
    
    # Then build with Xcode
    build_app(
      scheme: "Runner",
      workspace: "Runner.xcworkspace", 
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      output_directory: "./build",
      output_name: "Runner.ipa",
      include_bitcode: false,
      export_options: {
        provisioningProfiles: {
          ENV['APP_BUNDLE_ID'] || "test.cicd.appibc" => "match AppStore #{ENV['APP_BUNDLE_ID'] || 'test.cicd.appibc'}"
        }
      }
    )
  end

  # ğŸš€ Upload with retry mechanism
  private_lane :upload_to_testflight_with_retry do |options|
    upload_options = {
      skip_waiting_for_build_processing: options[:skip_waiting] || true,
      groups: options[:groups] || ["Internal Testers"],
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Automated Flutter build from #{ENV['GITHUB_REF_NAME'] || 'main'} branch"
    }
    
    # à¸ªà¸£à¹‰à¸²à¸‡ API key object à¸–à¹‰à¸²à¸¡à¸µ environment variables
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content = ENV['APP_STORE_CONNECT_API_KEY']
    
    if api_key_id && api_issuer_id && api_key_content
      upload_options[:api_key] = {
        key_id: api_key_id,
        issuer_id: api_issuer_id,
        key: api_key_content,
        duration: 1200,
        in_house: false
      }
      UI.success("âœ… Using API key object for TestFlight upload")
    else
      UI.message("âš ï¸ Using traditional auth for TestFlight upload")
    end
    
    begin
      upload_to_testflight(upload_options)
    rescue => e
      UI.error("âŒ Upload failed: #{e.message}")
      UI.message("ğŸ”„ Retrying upload...")
      
      # Retry without API key object (fallback to file-based)
      upload_options.delete(:api_key)
      upload_to_testflight(upload_options)
    end
  end

  # Error handling with cleanup
  error do |lane, exception|
    # Clean up API key file even on error
    cleanup_api_key_file
    
    error_message = "âŒ Flutter iOS deployment failed in lane '#{lane}': #{exception.message}"
    UI.error(error_message)
    raise exception
  end
end