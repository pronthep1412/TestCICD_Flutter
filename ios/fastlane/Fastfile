# ios/fastlane/Fastfile - Static iOS Fastlane Configuration
default_platform(:ios)

platform :ios do
  
  before_all do
    setup_ci if ENV['CI']
    ensure_bundle_exec
  end

  desc "Deploy to TestFlight"
  lane :deploy do |options|
    UI.message("🚀 Deploying Flutter iOS to TestFlight...")
    
    # Setup API key file first
    setup_api_key_file
    
    # Setup certificates
    setup_certificates
    
    # Build app
    build_flutter_app
    
    # Upload to TestFlight
    upload_to_testflight_with_retry(
      groups: ["Internal Testers"],
      skip_waiting: true
    )
    
    # Cleanup
    cleanup_api_key_file
    
    UI.success("🎉 Successfully deployed to TestFlight!")
  end

  desc "Build only"
  lane :build do
    UI.message("🔨 Building Flutter iOS app...")
    
    # Setup API key file first
    setup_api_key_file
    
    # Setup certificates
    setup_certificates
    
    # Build app
    build_flutter_app
    
    # Cleanup
    cleanup_api_key_file
    
    UI.success("✅ Flutter iOS build completed!")
  end

  # 🔑 Setup API key file ให้ Fastlane ใช้งาน
  private_lane :setup_api_key_file do
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content = ENV['APP_STORE_CONNECT_API_KEY']
    
    if api_key_id && api_issuer_id && api_key_content
      UI.message("✅ Setting up API key file")
      UI.message("   Key ID: #{api_key_id}")
      UI.message("   Issuer ID: #{api_issuer_id}")
      UI.message("   Content length: #{api_key_content.length} characters")
      
      # สร้าง directory สำหรับ API key
      api_key_dir = File.expand_path("~/.appstoreconnect/private_keys")
      FileUtils.mkdir_p(api_key_dir) unless Dir.exist?(api_key_dir)
      
      # เขียน API key ลงไฟล์
      api_key_file = File.join(api_key_dir, "AuthKey_#{api_key_id}.p8")
      File.write(api_key_file, api_key_content)
      
      # Set permissions
      File.chmod(0600, api_key_file)
      
      UI.success("✅ API key file created at: #{api_key_file}")
      
      # เก็บไว้ใน lane context เพื่อ cleanup ภายหลัง
      Actions.lane_context[:API_KEY_FILE_PATH] = api_key_file
      
    else
      UI.message("⚠️ API key environment variables not available")
      missing_items = []
      missing_items << "API_KEY_ID" unless api_key_id
      missing_items << "ISSUER_ID" unless api_issuer_id  
      missing_items << "KEY_CONTENT" unless api_key_content
      UI.message("Missing: #{missing_items.join(', ')}")
    end
  end

  # 🗑️ Cleanup API key file
  private_lane :cleanup_api_key_file do
    api_key_file = Actions.lane_context[:API_KEY_FILE_PATH]
    if api_key_file && File.exist?(api_key_file)
      File.delete(api_key_file)
      UI.message("🗑️ Cleaned up API key file")
    end
  end

  # 🔐 Setup certificates (simplified)
  private_lane :setup_certificates do
    UI.message("🔐 Setting up certificates...")
    
    match(
      type: "appstore",
      readonly: false
    )
    
    UI.success("✅ Certificates setup completed")
  end

  # 🔨 Build Flutter app
  private_lane :build_flutter_app do
    # Build Flutter app first
    sh("cd ../.. && flutter build ios --release --no-codesign")
    
    # Then build with Xcode
    build_app(
      scheme: "Runner",
      workspace: "Runner.xcworkspace", 
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      output_directory: "./build",
      output_name: "Runner.ipa",
      include_bitcode: false,
      export_options: {
        provisioningProfiles: {
          ENV['APP_BUNDLE_ID'] || "test.cicd.appibc" => "match AppStore #{ENV['APP_BUNDLE_ID'] || 'test.cicd.appibc'}"
        }
      }
    )
  end

  # 🚀 Upload with retry mechanism
  private_lane :upload_to_testflight_with_retry do |options|
    upload_options = {
      skip_waiting_for_build_processing: options[:skip_waiting] || true,
      groups: options[:groups] || ["Internal Testers"],
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Automated Flutter build from #{ENV['GITHUB_REF_NAME'] || 'main'} branch"
    }
    
    # สร้าง API key object ถ้ามี environment variables
    api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
    api_issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
    api_key_content = ENV['APP_STORE_CONNECT_API_KEY']
    
    if api_key_id && api_issuer_id && api_key_content
      upload_options[:api_key] = {
        key_id: api_key_id,
        issuer_id: api_issuer_id,
        key: api_key_content,
        duration: 1200,
        in_house: false
      }
      UI.success("✅ Using API key object for TestFlight upload")
    else
      UI.message("⚠️ Using traditional auth for TestFlight upload")
    end
    
    begin
      upload_to_testflight(upload_options)
    rescue => e
      UI.error("❌ Upload failed: #{e.message}")
      UI.message("🔄 Retrying upload...")
      
      # Retry without API key object (fallback to file-based)
      upload_options.delete(:api_key)
      upload_to_testflight(upload_options)
    end
  end

  # Error handling with cleanup
  error do |lane, exception|
    # Clean up API key file even on error
    cleanup_api_key_file
    
    error_message = "❌ Flutter iOS deployment failed in lane '#{lane}': #{exception.message}"
    UI.error(error_message)
    raise exception
  end
end